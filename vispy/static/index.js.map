{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/index.js","webpack:///./lib/vispy.min.js","webpack:///./lib/webgl-backend.js","webpack:///external \"@jupyter-widgets/base\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAuB;;AAEvB;AACA;AACA,2BAA2B,mBAAO,CAAC,kDAAoB;AACvD,4BAA4B,mBAAO,CAAC,uCAAiB;;;;;;;;;;;;ACZrD,qCAAa,GAAG,IAAsD,EAAE,mBAAmB,KAAK,UAA8N,CAAC,aAAa,0BAA0B,mBAAmB,kBAAkB,gBAAgB,UAAU,UAAU,0CAA0C,gBAAgB,OAAC,OAAO,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,eAAe,sBAAsB,oBAAoB,kDAAkD,WAAW,YAAY,SAAS,SAAS,KAAK;AAC1zB;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA,kDAAkD;AAClD,oDAAoD;AACpD,iDAAiD;AACjD,kDAAkD;AAClD,kDAAkD;AAClD,qDAAqD;;AAErD,gDAAgD;AAChD,kDAAkD;;AAElD,iDAAiD;AACjD,6CAA6C;AAC7C,4CAA4C;AAC5C,iDAAiD;;;;AAIjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B,EAAE;AAClD,CAAC;;;AAGD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,KAAK;AACL;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC,EAAE,qBAAqB;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,kCAAkC;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,EAAE;AAC9C;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B,EAAE;AAClD,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;;AAEA;AACA,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,uBAAuB;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA,0BAA0B;AAC1B,wBAAwB;AACxB,wBAAwB;AACxB,gCAAgC;AAChC;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,EAAE,OAAO,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE,OAAO,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gCAAgC,EAAE,gBAAgB,EAAE;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,EAAE,gBAAgB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,EAAE,OAAO,EAAE,QAAQ,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,EAAE,iBAAiB,EAAE;AACvD;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,EAAE,gBAAgB,EAAE;AACtD;;AAEA;AACA;AACA;AACA;AACA,2DAA2D,EAAE;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,EAAE,gBAAgB,EAAE;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,EAAE,iBAAiB,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,gBAAgB,EAAE,cAAc,EAAE;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE,QAAQ,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE,QAAQ,EAAE,oBAAoB,EAAE,YAAY,EAAE;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,EAAE,gBAAgB,EAAE;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,EAAE,gBAAgB,EAAE;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,EAAE,iBAAiB,EAAE;AACnE;AACA,KAAK;AACL;AACA,0BAA0B,EAAE,SAAS,EAAE,iBAAiB,EAAE,MAAM,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,EAAE;AACxC;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,EAAE,EAAE,EAAE;;AAE1B;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC,EAAE,iDAAiD;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA,CAAC,EAAE,mBAAmB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+GAA+G,aAAa,cAAc,oEAAoE,kVAAkV,oBAAoB,4CAA4C,eAAe,yBAAyB,4CAA4C,eAAe,+PAA+P,mCAAmC,qCAAqC,+LAA+L,aAAa,OAAO,gBAAgB,oEAAoE,iNAAiN,uCAAuC,EAAE,6CAA6C,kCAAkC,kCAAkC,4CAA4C,EAAE,oCAAoC,yBAAyB,wHAAwH,qBAAqB,+CAA+C,EAAE,uCAAuC,4BAA4B,wFAAwF,2BAA2B,gEAAgE,kGAAkG,2BAA2B,qBAAqB,WAAW,wCAAwC,aAAa,uBAAuB,8DAA8D,0BAA0B,oCAAoC,EAAE;AAC/iF,CAAC,GAAG;AACJ;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY,aAAa,8HAA8H,wtBAAwtB,IAAI,kCAAkC,mBAAmB,IAAI,oBAAoB,SAAS,SAAS,MAAM,oBAAoB,0BAA0B,0HAA0H,iBAAiB,6BAA6B,oBAAoB,8CAA8C,sBAAsB,qBAAqB,QAAQ,qCAAqC,cAAc,eAAe,uCAAuC,UAAU,6BAA6B,sCAAsC,UAAU,6BAA6B,wCAAwC,2DAA2D,qBAAqB,0DAA0D,oBAAoB,+FAA+F;AACryD,CAAC,GAAG;AACJ;AACA;AACA;AACA,0BAA0B,MAAM;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,KAAK,KAAK;AACxF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,CAAC,EAAE,8IAA8I;;AAEjJ;AACA;AACA;;AAEA;;AAEA,CAAC,GAAG,EAAE,GAAG;AACT,CAAC;;AAED,2CAA2C,cAAc;;;;;;;;;;;;;ACxsD5C;;AAEb,cAAc,mBAAO,CAAC,oDAAuB;AAC7C,YAAY,mBAAO,CAAC,0CAAgB;;AAEpC;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;;AAGL;AACA;AACA,E;;;;;;;;;;;;;;;;;;;;;;AC1JA,mE","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/index.js\");\n","// Entry point for the notebook bundle containing custom model definitions.\n//\n// Setup notebook base URL\n//\n// Some static assets may be required by the custom widget javascript. The base\n// url for the notebook is not known at build time and is therefore computed\n// dynamically.\n__webpack_public_path__ = document.querySelector('body').getAttribute('data-base-url') + 'nbextensions/vispy/';\n\n// Export widget models and views, and the npm package version number.\n// module.exports.vispy = require('./vispy.min.js');\nmodule.exports.VispyView = require('./webgl-backend.js').VispyView;\nmodule.exports['version'] = require('../package.json').version;\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vispy = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nfunction decode_base64(base64) {\n    var binary_string =  window.atob(base64);\n    var len = binary_string.length;\n    var bytes = new Uint8Array( len );\n    for (var i = 0; i < len; i++)        {\n        var ascii = binary_string.charCodeAt(i);\n        bytes[i] = ascii;\n    }\n    return bytes.buffer;\n}\n\n// Mapping between user-friendly data type string, and typed array classes.\nvar _typed_array_map = {\n    'float32': Float32Array,\n    'int8': Int8Array,\n    'int16': Int16Array,\n    'int32': Int32Array,\n    'uint8': Uint8Array,\n    'uint16': Uint16Array,\n    'uint32': Uint32Array,\n};\n\n\nfunction to_array_buffer(data) {\n    // Return a TypedArray from a JSON object describing a data buffer.\n    // storage_type is one of 'javascript_array', 'javascript_typed_array',\n    // 'base64', 'png'\n    var storage_type = data[\"storage_type\"];\n\n    // data can also be just a normal typed array, in which case we just return\n    // the argument value.\n    if (storage_type == undefined) {\n        return data;\n    }\n\n    var data_type = data[\"data_type\"];\n    var contents = data[\"buffer\"];\n\n    if (storage_type == \"javascript_array\") {\n        // A regular JavaScript array, the type must be specified in 'data_type'.\n        return _typed_array_map[data_type](contents);\n    }\n    else if (storage_type == \"javascript_typed_array\" ||\n             storage_type == \"array_buffer\") {\n        // A JavaScript Typedarray.\n        return contents;\n    }\n    else if (storage_type == \"binary\") {\n        // \"binary\" means that binary WebSocket has been used\n        // A JavaScript ArrayBuffer referenced by the data view.\n        return contents.buffer;\n    }\n    else if (storage_type == \"base64\") {\n        var array = decode_base64(contents);\n        return array;\n    }\n}\n\nmodule.exports = {\n    to_array_buffer: to_array_buffer\n};\n\n},{}],2:[function(require,module,exports){\nvar VispyCanvas = require('./vispycanvas.js');\n\n/* Internal functions */\nfunction get_pos(c, e) {\n    var rect = c.getBoundingClientRect();\n    return [e.clientX - rect.left,\n            e.clientY - rect.top];\n}\n\nfunction normalize_pos(c, pos) {\n    return [2*pos[0]/c.width-1, 1-2*pos[1]/c.height];\n}\n\nfunction get_modifiers(e) {\n    var modifiers = [];\n    if (e.altKey) modifiers.push('alt');\n    if (e.ctrlKey) modifiers.push('ctrl');\n    if (e.metaKey) modifiers.push('meta');\n    if (e.shiftKey) modifiers.push('shift');\n    return modifiers;\n}\n\nfunction get_key_text(keynum) {\n    return String.fromCharCode(keynum).toUpperCase().trim();\n}\n\nfunction _get_keynum(e){\n    if(window.event){ // IE\n        return e.keyCode;\n    }\n    else if(e.which){ // Netscape/Firefox/Opera\n        return e.which;\n    }\n}\n\nvar _key_map = {\n    8: 'BACKSPACE',\n    9: 'TAB',\n    13: 'ENTER',\n    16: 'SHIFT',\n    17: 'CONTROL',\n    18: 'ALT',\n    27: 'ESCAPE',\n    32: 'SPACE',\n    33: 'PAGEUP',\n    34: 'PAGEDOWN',\n    35: 'END',\n    36: 'HOME',\n    37: 'LEFT',\n    38: 'UP',\n    39: 'RIGHT',\n    40: 'DOWN',\n    45: 'INSERT',\n    46: 'DELETE',\n    91: 'META',\n    92: 'META',\n    96: '0',\n    97: '1',\n    98: '2',\n    99: '3',\n    100: '4',\n    101: '5',\n    102: '6',\n    103: '7',\n    104: '8',\n    105: '9',\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    112: 'F1',\n    113: 'F2',\n    114: 'F3',\n    115: 'F4',\n    116: 'F5',\n    117: 'F6',\n    118: 'F7',\n    119: 'F8',\n    120: 'F9',\n    121: 'F10',\n    122: 'F11',\n    123: 'F12',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\'',\n};\nfunction get_key_code(e){\n    // Return a string representation of a key. It will be interpreted by\n    // Vispy.\n    var keynum = _get_keynum(e);\n    var key_code = _key_map[keynum];\n    if (key_code == undefined) {\n        key_code = get_key_text(keynum);\n    }\n    return key_code;\n}\n\n\n/* Event generation */\nvar _button_map = {\n    0: 1,   // left\n    2: 2,   // right\n    1: 3,   // middle\n};\nfunction gen_mouse_event(c, e, type) {\n    if (c._eventinfo.is_button_pressed)\n        var button = _button_map[e.button];\n    else\n        button = null;\n    var pos = get_pos(c.$el.get(0), e);\n    var modifiers = get_modifiers(e);\n    var press_event = c._eventinfo.press_event;\n    var last_event = c._eventinfo.last_event;\n    var event = {\n        'type': type,\n        'pos': pos,\n        'button': button,\n        'is_dragging': press_event != null,\n        'modifiers': modifiers,\n        'delta': null,\n        'press_event': press_event,\n\n        'last_event': null,  // HACK: disabled to avoid recursion problems\n    }\n    return event;\n}\n\nfunction gen_resize_event(c, size) {\n    var event = {\n        'type': 'resize',\n        'size': size,\n    }\n    return event;\n}\n\nfunction gen_paint_event(c) {\n    var event = {\n        'type': 'paint',\n    }\n    return event;\n}\n\nfunction gen_initialize_event(c) {\n    var event = {\n        'type': 'initialize',\n    }\n    return event;\n}\n\nfunction gen_key_event(c, e, type) {\n    var modifiers = get_modifiers(e);\n    var last_event = c._eventinfo.last_event;\n    var event = {\n        'type': type,\n        'modifiers': modifiers,\n        'key_code': get_key_code(e),\n        'last_event': null,  // HACK: disabled to avoid recursion problems\n    }\n    return event;\n}\n\n\n\n/* Internal callback functions */\nVispyCanvas.prototype._mouse_press = function(e) { };\nVispyCanvas.prototype._mouse_release = function(e) { };\nVispyCanvas.prototype._mouse_move = function(e) { };\nVispyCanvas.prototype._mouse_wheel = function(e) { };\nVispyCanvas.prototype._mouse_click = function(e) { };\nVispyCanvas.prototype._mouse_dblclick = function(e) { };\n\nVispyCanvas.prototype._key_press = function(e) { };\nVispyCanvas.prototype._key_release = function(e) { };\n\nVispyCanvas.prototype._initialize = function(e) { };\nVispyCanvas.prototype._resize = function(e) { };\nVispyCanvas.prototype._paint = function(e) { };\nVispyCanvas.prototype._event_tick = function(e) { };\n\n\n\n/* Registering handlers */\nVispyCanvas.prototype.on_mouse_press = function(f) {\n    this._mouse_press = f;\n};\nVispyCanvas.prototype.on_mouse_release = function(f) {\n    this._mouse_release = f;\n};\nVispyCanvas.prototype.on_mouse_move = function(f) {\n    this._mouse_move = f;\n};\nVispyCanvas.prototype.on_mouse_wheel = function(f) {\n    this._mouse_wheel = f;\n};\nVispyCanvas.prototype.on_mouse_dblclick = function(f) {\n    this._mouse_dblclick = f;\n};\nVispyCanvas.prototype.on_key_press = function(f) {\n    this._key_press = f;\n};\nVispyCanvas.prototype.on_key_release = function(f) {\n    this._key_release = f;\n};\nVispyCanvas.prototype.on_initialize = function(f) {\n    this._initialize = f;\n};\nVispyCanvas.prototype.on_resize = function(f) {\n    this._resize = f;\n};\nVispyCanvas.prototype.on_paint = function(f) {\n    this._paint = f;\n};\nVispyCanvas.prototype.on_event_tick = function(f) {\n    this._event_tick = f;\n};\n\n\nVispyCanvas.prototype.initialize = function() {\n    var event = gen_initialize_event(this);\n    this._set_size();\n    this._initialize(event);\n};\nVispyCanvas.prototype._set_size = function(size) {\n    if (size == undefined) {\n        size = [this.$el.width(), this.$el.height()];\n    }\n    this.size = size;\n    this.width = size[0];\n    this.height = size[1];\n    return size;\n}\nVispyCanvas.prototype.paint = function() {\n    /* Add a paint event in the event queue. */\n    var event = gen_paint_event(this);\n    this.event_queue.append(event);\n};\nVispyCanvas.prototype.update = VispyCanvas.prototype.paint;\nVispyCanvas.prototype.resize = function(size) {\n    size = this._set_size(size);\n    var event = gen_resize_event(this, size);\n    this.gl.canvas.width = size[0];\n    this.gl.canvas.height = size[1];\n    // Put the resize event in the queue.\n    this.event_queue.append(event);\n    this._resize(event);\n};\n\nVispyCanvas.prototype.event_tick = function() {\n    this._event_tick();\n    var ncommands = this.execute_pending_commands();\n    if (ncommands > 0) {\n        // At least 1 GLIR command has been executed here.\n        // We call the on_paint callback function here.\n        var event = gen_paint_event(this);\n        this._paint(event);\n    }\n};\n\nVispyCanvas.prototype.is_fullscreen = function() {\n    return (screenfull.enabled) & (screenfull.isFullscreen);\n};\n\nVispyCanvas.prototype.toggle_fullscreen = function() {\n    if (screenfull.enabled) {\n        if(screenfull.isFullscreen) {\n            screenfull.exit();\n            this.resize(this._size);\n        }\n        else {\n            this.$el.width(\"100%\").height(\"100%\");\n            this._size = [this.$el.width(), this.$el.height()];\n            screenfull.request(this.$el[0]);\n            this.resize([screen.width, screen.height]);\n        }\n    }\n};\n\nVispyCanvas.prototype.deactivate_context_menu = function() {\n    document.oncontextmenu = function () { return false; };\n}\n\nVispyCanvas.prototype.resizable = function() {\n    var that = this;\n    this.$el.resizable({\n        resize: function(event, ui) {\n            that.resize([ui.size.width, ui.size.height]);\n        }\n    });\n};\n\n\n/* Event queue prototype */\nfunction _events_can_be_combined(e1, e2) {\n    // Return the list of properties to copy to e2.\n    // The returned list is non empty if the two events can be combined.\n    // It is empty if the two events cannot be combined.\n    var type = e1.type;\n    if (type == e2.type) {\n        if (type == 'mouse_move') {\n            if ((e1.button == e2.button) &\n                (e1.is_dragging == e2.is_dragging) &\n                (e1.modifiers.equals(e2.modifiers))) {\n                return ['pos'];\n            }\n        }\n        else {\n\n        }\n    }\n    return [];\n}\nfunction EventQueue(maxlen) {\n    if (maxlen == undefined) {\n        maxlen = 100;\n    }\n    this._queue = [];\n    this.maxlen = maxlen;\n}\nEventQueue.prototype.clear = function() {\n    this._queue = [];\n}\nEventQueue.prototype.append = function(e, compress) {\n    // Compression allows several similar consecutive events to be merged\n    // into a single event, for performance reasons (notably, 'mouse_move').\n    var add_to_queue = true;\n    if (compress == undefined) {\n        compress = true;\n    }\n    if (compress) {\n        // If the event type is identical to the last event, we\n        // just update the parameters instead of pushing a new event.\n        var last_event = this._queue[this._queue.length - 1];\n        if (last_event != undefined) {\n            // Get the list or properties to combine.\n            var props = _events_can_be_combined(e, last_event);\n            // Combine the properties.\n            if (props.length > 0) {\n                for (var i = 0; i < props.length; i++) {\n                    var prop = props[i];\n                    this._queue[this._queue.length - 1][prop] = e[prop];\n                }\n                // In this case, no need to add the new event to the queue\n                // because the last existing event can be updated (\"combined\"\n                // with the new one).\n                add_to_queue = false;\n            }\n        }\n    }\n    if (add_to_queue) {\n        this._queue.push(e);\n    }\n    // Remove the oldest element if the queue is longer than the maximum allowed side.\n    if (this._queue.length > this.maxlen) {\n        this._queue.shift();\n        // Remove the reference to the removed event in order to clean the GC.\n        this._queue[0].last_event = null;\n    }\n}\nEventQueue.prototype.get = function() {\n    return this._queue;\n}\nObject.defineProperty(EventQueue.prototype, \"length\", {\n    get: function() { return this._queue.length; },\n});\n\n\n/* Canvas initialization */\nfunction init_app(c) {\n\n    // Generate a resize event when the user resizes the canvas with\n    // jQuery resizable.\n    c.$el.resize(function(e) {\n            c.resize([e.width(), e.height()]);\n        }\n    );\n\n    c.event_queue = new EventQueue();\n\n    // This object stores some state necessary to generate the appropriate\n    // events.\n    c._eventinfo = {\n        'type': null,\n        'pos': null,\n        'button': null,\n        'is_dragging': null,\n        'key': null,\n        'modifiers': [],\n        'press_event': null,\n        'last_event': null,\n        'delta': null,\n    }\n\n    // HACK: boolean stating whether a mouse button is pressed.\n    // This is necessary because e.button==0 in two cases: no\n    // button is pressed, or the left button is pressed.\n    c._eventinfo.is_button_pressed = 0;\n\n    c.$el.mousemove(function(e) {\n        var event = gen_mouse_event(c, e, 'mouse_move');\n\n        // Vispy callbacks.\n        c._mouse_move(event);\n\n        // Save the last event.\n        // c._eventinfo.last_event = event;\n        c.event_queue.append(event);\n    });\n    c.$el.mousedown(function(e) {\n        ++c._eventinfo.is_button_pressed;\n        var event = gen_mouse_event(c, e, 'mouse_press');\n\n        // Vispy callbacks.\n        c._mouse_press(event);\n\n        // Save the last press event.\n        c._eventinfo.press_event = event;\n        // Save the last event.\n        // c._eventinfo.last_event = event;\n        c.event_queue.append(event);\n    });\n    c.$el.mouseup(function(e) {\n        --c._eventinfo.is_button_pressed;\n        var event = gen_mouse_event(c, e, 'mouse_release');\n\n        // Vispy callbacks.\n        c._mouse_release(event);\n\n        // Reset the last press event.\n        c._eventinfo.press_event = null;\n        // Save the last event.\n        // c._eventinfo.last_event = event;\n        c.event_queue.append(event);\n    });\n    c.$el.click(function(e) {\n        // Reset the last press event.\n        c._eventinfo.press_event = null;\n    });\n    c.$el.dblclick(function(e) {\n\n        // Reset the last press event.\n        c._eventinfo.press_event = null;\n    });\n    // This requires the mouse wheel jquery plugin.\n    if (c.$el.mousewheel != undefined) {\n        c.$el.mousewheel(function(e) {\n            var event = gen_mouse_event(c, e, 'mouse_wheel');\n            event.delta = [e.deltaX * e.deltaFactor * .01,\n                           e.deltaY * e.deltaFactor * .01];\n\n            // Vispy callbacks.\n            c._mouse_wheel(event);\n\n            // Save the last event.\n            // c._eventinfo.last_event = event;\n            c.event_queue.append(event);\n\n            e.preventDefault();\n            e.stopPropagation();\n        });\n    }\n\n    c.$el.keydown(function(e) {\n        var event = gen_key_event(c, e, 'key_press');\n\n        // Vispy callbacks.\n        c._key_press(event);\n\n        // Save the last event.\n        // c._eventinfo.last_event = event;\n        c.event_queue.append(event);\n    });\n    c.$el.keyup(function(e) {\n        var event = gen_key_event(c, e, 'key_release');\n\n        // Vispy callbacks.\n        c._key_release(event);\n\n        // Save the last event.\n        // c._eventinfo.last_event = event;\n        c.event_queue.append(event);\n    });\n\n    c.$el.mouseout(function(e) {\n    });\n}\n\n\n/* Creation of vispy.events */\nvar events = function() {\n    // Constructor.\n\n};\n\nevents.prototype.init = function(c) {\n    init_app(c);\n};\n\nmodule.exports = new events();\n\n},{\"./vispycanvas.js\":9}],3:[function(require,module,exports){\nvar VispyCanvas = require('./vispycanvas.js');\nvar util = require('./util.js');\nvar data = require('./data.js');\n\nvar debug = util.debug;\nvar to_array_buffer = data.to_array_buffer;\nvar JUST_DELETED = 'JUST_DELETED';\n\n/* WebGL utility functions */\nfunction viewport(c) {\n    c.gl.viewport(0, 0, c.width(), c.height());\n}\n\nfunction clear(c, color) {\n    c.gl.clearColor(color[0], color[1], color[2], color[3]);\n    c.gl.clear(c.gl.COLOR_BUFFER_BIT);\n}\n\nfunction compile_shader(c, shader, source) {\n    // TODO: Convert desktop GLSL code if needed\n    console.log(typeof source);\n    if (typeof source !== 'string') {\n        // assume we have a buffer\n        source = String.fromCharCode.apply(null, new Uint8Array(source));\n\n    }\n    source = source.replace(/\\\\n/g, \"\\n\");\n\n    c.gl.shaderSource(shader, source);\n    c.gl.compileShader(shader);\n\n    if (!c.gl.getShaderParameter(shader, c.gl.COMPILE_STATUS))\n    {\n        console.error(c.gl.getShaderInfoLog(shader));\n        return false;\n    }\n\n    return true;\n}\n\nfunction create_attribute(c, program, name) {\n    var attribute_handle = c.gl.getAttribLocation(program, name);\n    return attribute_handle;\n}\n\nfunction activate_attribute(c, attribute_handle, vbo_id, type, stride, offset) {\n    // attribute_handle: attribute handle\n    // vbo_id\n    // type: float, vec3, etc.\n    // stride: 0 by default\n    // offset: 0 by default\n    var _attribute_info = get_attribute_info(type);\n    var attribute_type = _attribute_info[0];  // FLOAT, INT or BOOL\n    var ndim = _attribute_info[1]; // 1, 2, 3 or 4\n\n    _vbo_info = c._ns[vbo_id];\n    var vbo_handle = _vbo_info.handle;\n\n    c.gl.enableVertexAttribArray(attribute_handle);\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, vbo_handle);\n    c.gl.vertexAttribPointer(attribute_handle, ndim,\n                             c.gl[attribute_type],\n                             false, stride, offset);\n}\n\nfunction deactivate_attribute(c, attribute_handle) {\n    // c.gl.bindBuffer(c.gl.GL_ARRAY_BUFFER, 0);\n    c.gl.disableVertexAttribArray(attribute_handle);\n}\n\nfunction activate_texture(c, texture_handle, sampler_handle, texture_index) {\n    if (texture_handle === JUST_DELETED) {\n        return;\n    }\n    c.gl.activeTexture(c.gl.TEXTURE0 + texture_index);\n    c.gl.bindTexture(c.gl.TEXTURE_2D, texture_handle);\n    // c.gl.uniform1i(sampler_handle, 0);\n}\n\nfunction deactivate_texture(c, texture_handle, sampler_handle, texture_index) {\n    c.gl.activeTexture(c.gl.TEXTURE0 + texture_index);\n    c.gl.bindTexture(c.gl.TEXTURE_2D, null);\n}\n\nfunction _get_alignment(width) {\n    /* Determines a textures byte alignment.\n\n    If the width isn't a power of 2\n    we need to adjust the byte alignment of the image.\n    The image height is unimportant\n\n    www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n\n    we know the alignment is appropriate\n    if we can divide the width by the\n    alignment cleanly\n    valid alignments are 1,2,4 and 8\n    4 is the default\n\n    */\n    var alignments = [8, 4, 2, 1];\n    for (var i = 0; i < alignments.length; i++) {\n        if (width % alignments[i] == 0) {\n            return alignments[i];\n        }\n    }\n}\n\nfunction set_texture_data(c, object_handle, gl_type, format, width, height, array, offset, shape, dtype) {\n    c.gl.bindTexture(gl_type, object_handle);\n\n    // TODO: choose a better alignment\n    c.gl.pixelStorei(c.gl.UNPACK_ALIGNMENT, 1);\n\n    if (array === null) {\n        // special texture attached to frame buffer to be rendered to\n        c.gl.texImage2D(gl_type, 0, format, width, height, 0, format, c.gl.UNSIGNED_BYTE, array);\n    } else if (array.getContext) {\n        // A canvas object\n        c.gl.texImage2D(gl_type, 0, c.gl.RGBA, c.gl.RGBA, c.gl.UNSIGNED_BYTE, array);\n    } else if (array.canvas) {\n        // A context object\n        c.gl.texImage2D(gl_type, 0, c.gl.RGBA, c.gl.RGBA, c.gl.UNSIGNED_BYTE, array.canvas);\n    } else {\n        var array_view;\n        if (dtype == c.gl.FLOAT) {\n            array_view = new Float32Array(array);\n        } else {\n            array_view = new Uint8Array(array);\n        }\n\n        // if this isn't initializing the texture (texImage2D) then see if we\n        // can set just part of the texture\n        if (offset && shape && ((shape[0] !== height) || (shape[1] !== width))) {\n            var width = shape[shape.length - 2] * shape[shape.length - 1];\n            var alignment = _get_alignment(width);\n            c.gl.pixelStorei(c.gl.UNPACK_ALIGNMENT, alignment);\n            c.gl.texSubImage2D(gl_type, 0, offset[1], offset[0],\n                shape[1], shape[0], format, dtype, array_view);\n        } else {\n            c.gl.pixelStorei(c.gl.UNPACK_ALIGNMENT, 1);\n            c.gl.texImage2D(gl_type, 0, format, width, height, 0,\n                format, dtype, array_view);\n        }\n    }\n}\n\nfunction set_buffer_data(c, object_handle, gl_type, offset, array, reuse) {\n    // Bind the buffer before setting the data.\n    c.gl.bindBuffer(gl_type, object_handle);\n\n    // Upload the data.\n    if (!reuse) {\n        // The existing buffer was empty: we create it.\n        c.gl.bufferData(gl_type, array, c.gl.STATIC_DRAW);\n    }\n    else {\n        // We reuse the existing buffer.\n        c.gl.bufferSubData(gl_type, offset, array);\n    }\n}\n\nfunction set_uniform(c, uniform_handle, uniform_function, value) {\n    // Get a TypedArray.\n    array = to_array_buffer(value);\n\n    if (uniform_function.indexOf('Matrix') > 0) {\n        // Matrix uniforms.\n        c.gl[uniform_function](uniform_handle, false, array);\n    }\n    else {\n        // Scalar uniforms.\n        c.gl[uniform_function](uniform_handle, array);\n    }\n}\n\nvar _dtype_to_gl_dtype = {\n    'float32': 'FLOAT',\n    'uint8': 'UNSIGNED_BYTE',\n};\nfunction get_gl_dtype(dtype) {\n    return _dtype_to_gl_dtype[dtype];\n}\n\nvar _attribute_type_map = {\n    'float': ['FLOAT', 1],\n    'vec2': ['FLOAT', 2],\n    'vec3': ['FLOAT', 3],\n    'vec4': ['FLOAT', 4],\n\n    'int': ['INT', 1],\n    'ivec2': ['INT', 2],\n    'ivec3': ['INT', 3],\n    'ivec4': ['INT', 4],\n};\nfunction get_attribute_info(type) {\n    // type: vec2, ivec3, float, etc.\n    return _attribute_type_map[type];\n}\n\nvar _uniform_type_map = {\n    'float': 'uniform1fv',\n    'vec2': 'uniform2fv',\n    'vec3': 'uniform3fv',\n    'vec4': 'uniform4fv',\n\n    'int': 'uniform1iv',\n    'ivec2': 'uniform2iv',\n    'ivec3': 'uniform3iv',\n    'ivec4': 'uniform4iv',\n\n    'mat2': 'uniformMatrix2fv',\n    'mat3': 'uniformMatrix3fv',\n    'mat4': 'uniformMatrix4fv',\n};\nfunction get_uniform_function(type) {\n    // Find OpenGL uniform function.\n    return _uniform_type_map[type];\n}\n\nvar _gl_type_map = {\n    VertexBuffer: 'ARRAY_BUFFER',\n    IndexBuffer: 'ELEMENT_ARRAY_BUFFER',\n    Texture2D: 'TEXTURE_2D',\n};\n\nfunction get_gl_type(object_type) {\n    return _gl_type_map[object_type];\n}\n\nvar _gl_attachment_map = {\n    'color': ['COLOR_ATTACHMENT0', 'RGBA4'],\n    'depth': ['DEPTH_ATTACHMENT', 'DEPTH_COMPONENT16'],\n    'stencil': ['STENCIL_ATTACHMENT', 'STENCIL_INDEX8'],\n};\n\nfunction get_attachment_type(type_str) {\n    return _gl_attachment_map[type_str][0];\n}\n\nfunction get_attachment_format(type_str) {\n    return _gl_attachment_map[type_str][1];\n}\n\nfunction parse_enum(c, str) {\n    // Parse an enum or combination of enums stored in a string.\n    var strs = str.split('|');\n    var value = 0;\n    for (var i = 0; i < strs.length; i++) {\n        var name = strs[i].toUpperCase().trim();\n        value = value | c.gl[name];\n    }\n    return value;\n}\n\nfunction validate_framebuffer(c) {\n    var status = c.gl.checkFramebufferStatus(c.gl.FRAMEBUFFER);\n    if (status == c.gl.FRAMEBUFFER_COMPLETE) {\n        return;\n    }\n    // c.gl.FRAMEBUFFER_INCOMPLETE_FORMATS: // not in es 2.0\n    //     'Internal format of attachment is not renderable.'\n    if (status == c.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {\n        throw 'FrameBuffer attachments are incomplete.';\n    }\n    else if (status == c.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {\n        throw 'No valid attachments in the FrameBuffer.';\n    }\n    else if (status == c.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {\n        throw 'attachments do not have the same width and height.';\n    }\n    else if (status == c.gl.FRAMEBUFFER_UNSUPPORTED) {\n        throw 'Combination of internal formats used by attachments is not supported.';\n    }\n    else {\n        throw 'Unknown framebuffer error' + status;\n    }\n}\n\nfunction activate_framebuffer(c, framebuffer_id) {\n    var fb = c._ns[framebuffer_id];\n    var stack = c.env.fb_stack;\n    if (stack.length == 0) {\n        stack.push(null);\n    }\n\n    if (stack[stack.length - 1] === fb.handle) {\n        debug(\"Frame buffer already active {0}\".format(framebuffer_id));\n        return;\n    }\n    debug(\"Binding frame buffer {0}.\".format(framebuffer_id));\n    c.gl.bindFramebuffer(c.gl.FRAMEBUFFER, fb.handle);\n    stack.push(fb.handle);\n}\n\nfunction deactivate_framebuffer(c, framebuffer_id) {\n    var fb = c._ns[framebuffer_id];\n    var stack = c.env.fb_stack;\n    if (stack.length == 0) {\n        stack.push(null);\n    }\n\n    while (stack[stack.length - 1] === fb.handle) {\n        // Deactivate current frame buffer\n        stack.pop(); // 'unbind' current buffer\n    }\n    // Activate previous frame buffer\n    // NOTE: out of bounds index if trying to unbind the default (null) framebuffer\n    debug(\"Binding previous frame buffer\");\n    c.gl.bindFramebuffer(c.gl.FRAMEBUFFER, stack[stack.length - 1]);\n}\n\nfunction init_env_cache(c) {\n    c.env = {\n        'fb_stack': [],\n    };\n}\n\n\n/* Glir queue prototype */\nfunction GlirQueue() {\n    this._queue = [];\n}\nGlirQueue.prototype.clear = function() {\n    this._queue = [];\n};\nGlirQueue.prototype.append = function(e) {\n    this._queue.push(e);\n};\nGlirQueue.prototype.append_multi = function(es) {\n    for (var i = 0; i < es.length; i++) {\n        this._queue.push(es[i]);\n    }\n};\nGlirQueue.prototype.get = function() {\n    return this._queue;\n};\nObject.defineProperty(GlirQueue.prototype, \"length\", {\n    get: function() { return this._queue.length; },\n});\n\n\n/* Vispy canvas GLIR methods */\nVispyCanvas.prototype.set_deferred = function(deferred) {\n    this._deferred = deferred;\n};\n\nVispyCanvas.prototype.execute_pending_commands = function() {\n    /* Return the number of executed GLIR commands. */\n    var q = this.glir_queue.get();\n    var execute_up_to = -1;\n    if (q.length == 0) {\n        return 0;\n    }\n\n    // Only start executing if we see a SWAP command\n    // Any 'draw' command (clear, draw, etc) will cause the browser to\n    // swap the webgl drawing buffers. If we start executing draw commands\n    // before we are ready for the buffers to swap we could get an incomplete\n    // canvas (only 'clear' being completed, less than all of the\n    // expected objects being drawn, etc).\n    // This technically only happens if not all the GLIR commands were\n    // received by the time this animation loop started.\n    for (var i = 0; i < q.length; i++) {\n        if (q[i][0] === 'SWAP') {\n            execute_up_to = i;\n            break;\n        }\n    }\n    // Execute all commands up to and including the SWAP\n    for (i = 0; i <= execute_up_to; i++) {\n        this.command(q[i], false);\n    }\n\n    if (execute_up_to >= 0) {\n        debug(\"Processed {0} events.\".format(execute_up_to + 1));\n        // this.glir_queue.clear();\n        this.glir_queue._queue = this.glir_queue._queue.slice(execute_up_to + 1);\n    }\n    return execute_up_to + 1;\n};\n\nVispyCanvas.prototype.command = function(command, deferred) {\n    if (deferred === undefined) {\n        deferred = this._deferred;\n    }\n    var method = command[0].toLowerCase();\n    if (deferred) {\n        this.glir_queue.append(command);\n    }\n    else {\n        this.glir[method](this, command.slice(1));\n    }\n};\n\n\n/* Creation of vispy.gloo.glir */\nvar glir = function() { };\n\nglir.prototype.init = function(c) {\n    // Namespace with the table of all symbols used by GLIR.\n\n    // The key is user-specified and is named the **id**.\n    // The WebGL internal handle is called the **handle**.\n\n    // For each id key, the value is an object with the following properties:\n    // * object_type ('VertexBuffer', 'Program', etc.)\n    // * handle (the WebGL internal handle, for all objects)\n    // * data_type (for Buffers)\n    // * offset (for Buffers)\n    // * attributes (for Programs)\n    // * uniforms (for Programs)\n    c._ns = {};\n    // Deferred mode is enabled by default.\n    c._deferred = true;\n    // Per-context storage for GLIR objects (framebuffer stack, etc)\n    init_env_cache(c);\n    c.glir_queue = new GlirQueue();\n    c.glir = this;\n};\n\nglir.prototype.current = function(c, args) {\n    init_env_cache(c);\n    c.gl.bindFramebuffer(c.gl.FRAMEBUFFER, null);\n};\n\nglir.prototype.swap = function(c, args) {\n\n};\n\nglir.prototype.create = function(c, args) {\n    var id = args[0];\n    var cls = args[1];\n    if (cls == 'VertexBuffer') {\n        debug(\"Creating vertex buffer '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createBuffer(),\n            size: 0,  // current size of the buffer\n        };\n    }\n    else if (cls == 'IndexBuffer') {\n        debug(\"Creating index buffer '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createBuffer(),\n            size: 0,  // current size of the buffer\n        };\n    }\n    else if (cls == 'FrameBuffer') {\n        debug(\"Creating frame buffer '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createFramebuffer(),\n            size: 0,  // current size of the buffer\n            validated: false,\n        };\n    }\n    else if (cls == 'RenderBuffer') {\n        debug(\"Creating render buffer '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createRenderbuffer(),\n            size: 0,  // current size of the buffer\n        };\n    }\n    else if (cls == 'Texture2D') {\n        debug(\"Creating texture '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createTexture(),\n            size: 0,  // current size of the texture\n            shape: [],\n        };\n    }\n    else if (cls == 'Program') {\n        debug(\"Creating program '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createProgram(),\n            attributes: {},\n            uniforms: {},\n            textures: {}, // map texture_id -> sampler_name, sampler_handle, number, handle\n            texture_uniforms: {}, // map sampler_name -> texture_id\n        };\n    }\n    else if (cls == 'VertexShader') {\n        debug(\"Creating VertexShader '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createShader(c.gl['VERTEX_SHADER']),\n        };\n    }\n    else if (cls == 'FragmentShader') {\n        debug(\"Creating FragmentShader '{0}'.\".format(id));\n        c._ns[id] = {\n            object_type: cls,\n            handle: c.gl.createShader(c.gl['FRAGMENT_SHADER']),\n        };\n    }\n};\n\nglir.prototype.delete = function(c, args) {\n    var id = args[0];\n    var cls = c._ns[id].object_type;\n    var handle = c._ns[id].handle;\n    c._ns[id].handle = JUST_DELETED;\n    if (cls == 'VertexBuffer') {\n        debug(\"Deleting vertex buffer '{0}'.\".format(id));\n        c.gl.deleteBuffer(handle);\n    }\n    else if (cls == 'IndexBuffer') {\n        debug(\"Deleting index buffer '{0}'.\".format(id));\n        c.gl.deleteBuffer(handle);\n    }\n    else if (cls == 'FrameBuffer') {\n        debug(\"Deleting frame buffer '{0}'.\".format(id));\n        c.gl.deleteFramebuffer(handle);\n    }\n    else if (cls == 'RenderBuffer') {\n        debug(\"Deleting render buffer '{0}'.\".format(id));\n        c.gl.deleteRenderbuffer(handle);\n    }\n    else if (cls == 'Texture2D') {\n        debug(\"Deleting texture '{0}'.\".format(id));\n        c.gl.deleteTexture(handle);\n    }\n    else if (cls == 'Program') {\n        debug(\"Deleting program '{0}'.\".format(id));\n        c.gl.deleteProgram(handle);\n    }\n    else if (cls.indexOf('Shader') >= 0) {\n        debug(\"Deleting shader '{0}'.\".format(id));\n        c.gl.deleteShader(handle);\n    }\n};\n\nglir.prototype.size = function(c, args) {\n    var object_id = args[0];\n    var size = args[1];  // WARNING: size must be in bytes!\n    var format = args[2];\n    var object = c._ns[object_id];\n    var object_handle = object.handle;\n    var object_type = object.object_type;\n    var gl_type = c.gl[get_gl_type(object_type)];\n\n    // Textures.\n    if (object_type.indexOf('Texture') >= 0) {\n        // format is 'LUMINANCE', 'ALPHA', 'LUMINANCE_ALPHA', 'RGB' or 'RGBA'\n        object.format = format.toUpperCase();\n        debug(\"Setting texture size to {1} for '{0}'.\".format(object_id, size));\n        // HACK: it doesn't seem we can change the texture size without\n        // allocating a buffer in WebGL, so we just store the size and\n        // format in the object, and we'll use this information in the\n        // subsequent DATA call.\n    }\n    else if (object_type == 'RenderBuffer') {\n        c.gl.bindRenderbuffer(c.gl.RENDERBUFFER, object_handle);\n        object.format = c.gl[get_attachment_format(format)];\n        // size is Y, X, Z\n        // assume Y is rows (height), X is columns (width)\n        // assume Z is color information (ignored)\n        c.gl.renderbufferStorage(c.gl.RENDERBUFFER, object.format, size[1], size[0]);\n        c.gl.bindRenderbuffer(c.gl.RENDERBUFFER, null);\n    }\n    // Buffers\n    else\n    {\n        debug(\"Setting buffer size to {1} for '{0}'.\".format(object_id, size));\n        // Reuse the buffer if the existing size is not null.\n        set_buffer_data(c, object_handle, gl_type, 0, size, false);\n    }\n    // Save the size.\n    object.size = size;\n};\n\nglir.prototype.data = function(c, args) {\n    var object_id = args[0];\n    var offset = args[1];\n    var data = args[2];\n    var object = c._ns[object_id];\n    var object_type = object.object_type; // VertexBuffer, IndexBuffer, or Texture2D\n    var object_handle = object.handle;\n    var gl_type = c.gl[get_gl_type(object_type)];\n    // Get a TypedArray.\n    var array = to_array_buffer(data);\n\n    if (object_type.indexOf('Shader') >= 0) {\n        // Compile shader code to shader object\n        compile_shader(c, object_handle, array);\n    }\n    // Textures.\n    else if (object_type.indexOf('Texture') >= 0) {\n        // The texture shape was specified in SIZE\n        var shape = object.size;\n        // WARNING: this is height and then width, not the other way\n        // around.\n        var height = shape[0];\n        var width = shape[1];\n\n        // The texture format was specified in SIZE.\n        var format = c.gl[object.format];\n\n        debug(\"Setting texture data for '{0}'.\".format(object_id));\n        // `data.shape` comes from notebook backend and vispy webgl extension\n        // without it, subimage texture writes do not work\n        var gl_dtype = c.gl[get_gl_dtype(data.dtype)];\n        set_texture_data(c, object_handle, gl_type, format, width, height, array, offset, data.shape, gl_dtype);\n        object.shape = shape;\n    }\n    // Buffers\n    else\n    {\n        debug(\"Setting buffer data for '{0}'.\".format(object_id));\n        // Reuse the buffer if the existing size is not null.\n        set_buffer_data(c, object_handle, gl_type, offset, array, object.size > 0);\n        object.size = array.byteLength;\n    }\n};\n\nglir.prototype.attribute = function(c, args) {\n    var program_id = args[0];\n    var name = args[1];\n    var type = args[2];\n    // TODO: support non-VBO data\n    var vbo_id = args[3][0];\n    var stride = args[3][1];\n    var offset = args[3][2];\n\n    var program_handle = c._ns[program_id].handle;\n\n    debug(\"Creating attribute '{0}' for program '{1}'.\".format(\n            name, program_id\n        ));\n    var attribute_handle = create_attribute(c, program_handle, name);\n\n    // Store the attribute handle in the attributes array of the program.\n    c._ns[program_id].attributes[name] = {\n        handle: attribute_handle,\n        type: type,\n        vbo_id: vbo_id,\n        stride: stride,\n        offset: offset,\n    };\n};\n\nglir.prototype.uniform = function(c, args) {\n    var program_id = args[0];\n    var name = args[1];\n    var type = args[2];\n    var value = args[3];\n\n    var program_handle = c._ns[program_id].handle;\n\n    c.gl.useProgram(program_handle);\n\n    // Check the cache.\n    if (c._ns[program_id].uniforms[name] == undefined) {\n        // If necessary, we create the uniform and cache both its handle and\n        // GL function.\n        debug(\"Creating uniform '{0}' for program '{1}'.\".format(\n                name, program_id\n            ));\n        var uniform_handle = c.gl.getUniformLocation(program_handle, name);\n        var uniform_function = get_uniform_function(type);\n        // We cache the uniform handle and the uniform function name as well.\n        c._ns[program_id].uniforms[name] = [uniform_handle, uniform_function];\n    }\n\n    debug(\"Setting uniform '{0}' to '{1}' with {2} elements.\".format(\n            name, value, value.length\n        ));\n    var uniform_info = c._ns[program_id].uniforms[name];\n    var uniform_handle = uniform_info[0];\n    var uniform_function = uniform_info[1];\n    set_uniform(c, uniform_handle, uniform_function, value);\n};\n\nglir.prototype.texture = function(c, args) {\n    var program_id = args[0];\n    var sampler_name = args[1];\n    var texture_id = args[2];\n\n    var program = c._ns[program_id];\n    var program_handle = program.handle;\n    var texture_handle = c._ns[texture_id].handle;\n\n    if (texture_handle === JUST_DELETED) {\n        debug(\"Removing texture '{0}' from program '{1}'\".format(\n            texture_id, program_id\n        ));\n        delete program.textures[texture_id];\n        return;\n    }\n\n    debug(\"Initializing texture '{0}' for program '{1}'.\".format(\n        texture_id, program_id));\n\n    // FIXME: Probably should store textures by sampler name, not texture id\n    if (program.texture_uniforms.hasOwnProperty(sampler_name)) {\n        // This program has had this sampler uniform name set before\n        // Let's remove the old one\n        debug('Removing previously assigned texture for \\'{0}\\''.format(sampler_name))\n        delete program.textures[program.texture_uniforms[sampler_name]];\n    }\n\n    // Set the sampler uniform value.\n    var sampler_handle = c.gl.getUniformLocation(program_handle, sampler_name);\n    program.texture_uniforms[sampler_name] = texture_id;\n\n    c._ns[program_id].textures[texture_id] = {\n        sampler_name: sampler_name,\n        sampler_handle: sampler_handle,\n        number: -1, // assigned later\n        handle: texture_handle,\n    };\n};\n\nglir.prototype.interpolation = function(c, args) {\n    var texture_id = args[0];\n    var min = args[1].toUpperCase();\n    var mag = args[2].toUpperCase();\n    var texture_handle = c._ns[texture_id].handle;\n\n    var gl_type = c.gl.TEXTURE_2D;\n    c.gl.bindTexture(gl_type, texture_handle);\n    c.gl.texParameteri(gl_type, c.gl.TEXTURE_MIN_FILTER, c.gl[min]);\n    c.gl.texParameteri(gl_type, c.gl.TEXTURE_MAG_FILTER, c.gl[mag]);\n    c.gl.bindTexture(gl_type, null);\n};\n\nglir.prototype.wrapping = function(c, args) {\n    var texture_id = args[0];\n    var wrapping = args[1];\n    var texture_handle = c._ns[texture_id].handle;\n\n    var gl_type = c.gl.TEXTURE_2D;\n    c.gl.bindTexture(gl_type, texture_handle);\n    c.gl.texParameteri(gl_type, c.gl.TEXTURE_WRAP_S,\n                       c.gl[wrapping[0].toUpperCase()]);\n    c.gl.texParameteri(gl_type, c.gl.TEXTURE_WRAP_T,\n                       c.gl[wrapping[1].toUpperCase()]);\n    c.gl.bindTexture(gl_type, null);\n};\n\nglir.prototype.draw = function(c, args) {\n    var program_id = args[0];\n    var mode = args[1].toUpperCase();\n    var selection = args[2];\n\n    var program_handle = c._ns[program_id].handle;\n    var attributes = c._ns[program_id].attributes;\n    var textures = c._ns[program_id].textures;\n    var texture_number = 0;\n\n    // Activate the program.\n    c.gl.useProgram(program_handle);\n\n    // Activate all attributes in the program.\n    for (attribute_name in attributes) {\n        var attribute = attributes[attribute_name];\n        debug(\"Activating attribute '{0}' for program '{1}'.\".format(\n            attribute_name, program_id));\n        activate_attribute(c, attribute.handle, attribute.vbo_id,\n            attribute.type, attribute.stride, attribute.offset);\n    }\n\n    // Activate all textures in the program.\n    for (texture_id in textures) {\n        var texture = textures[texture_id];\n        if (c._ns[texture_id].handle === JUST_DELETED) {\n            debug(\"Ignoring texture '{0}' from program '{1}'\".format(\n                texture_id, program_id\n            ));\n            texture.handle = JUST_DELETED;\n            continue;\n        }\n        texture.number = texture_number;\n        texture_number += 1;\n        debug(\"Activating texture '{0}' for program '{1}' as number '{2}'.\".format(\n            texture_id, program_id, texture.number));\n        activate_texture(c, texture.handle, texture.sampler_handle, texture.number);\n        c.gl.uniform1i(texture.sampler_handle, texture.number);\n    }\n\n    // Draw the program.\n    if (selection.length == 2) {\n        // Draw the program without index buffer.\n        var start = selection[0];\n        var count = selection[1];\n        debug(\"Rendering program '{0}' with {1}.\".format(\n            program_id, mode));\n        c.gl.drawArrays(c.gl[mode], start, count);\n    }\n    else if (selection.length == 3) {\n        // Draw the program with index buffer.\n        var index_buffer_id = selection[0];\n        var index_buffer_type = selection[1];\n        var count = selection[2];\n        // Get the index buffer handle from the namespace.\n        var index_buffer_handle = c._ns[index_buffer_id].handle;\n        debug(\"Rendering program '{0}' with {1} and index buffer '{2}' of type '{3}'.\".format(\n            program_id, mode, index_buffer_id, index_buffer_type));\n        // Activate the index buffer.\n        c.gl.bindBuffer(c.gl.ELEMENT_ARRAY_BUFFER, index_buffer_handle);\n        c.gl.drawElements(c.gl[mode], count, c.gl[index_buffer_type], 0);\n    }\n\n    // Deactivate attributes.\n    for (attribute_name in attributes) {\n        debug(\"Deactivating attribute '{0}' for program '{1}'.\".format(\n            attribute_name, program_id));\n        deactivate_attribute(c, attributes[attribute_name].handle);\n    }\n\n    // Deactivate textures.\n    var new_textures = {};\n    for (texture_id in textures) {\n        var texture = textures[texture_id];\n        debug(\"Deactivating texture '{0}' for program '{1}'.\".format(\n            texture_id, program_id));\n        deactivate_texture(c, texture.handle, texture.sampler_handle, texture.number);\n\n        // Don't include any of the textures that were deleted in this program\n        if (c._ns[texture_id].handle != JUST_DELETED) {\n            new_textures[texture_id] = texture;\n        }\n    }\n    c._ns[program_id].textures = new_textures;\n};\n\nglir.prototype.attach = function(c, args) {\n    // framebuffer or shader object ID\n    var dst_id = args[0];\n    var dst_obj = c._ns[dst_id];\n    var dst_type = dst_obj.object_type;\n    var dst_handle = dst_obj.handle;\n    if (dst_type == 'Program') {\n        // attaching to program, must be a shader we're attaching\n        var shader_id = args[1];\n        var shader_handle = c._ns[shader_id].handle;\n        c.gl.attachShader(dst_handle, shader_handle);\n        return;\n    }\n\n    // Attach to framebuffer\n    var object_id = args[2];\n    var attach_type = c.gl[get_attachment_type(args[1])];\n    var object;\n    activate_framebuffer(c, dst_id);\n    if (object_id == 0) {\n        debug('Attaching RenderBuffer object {0} to framebuffer {1}'.format(object_id, dst_id));\n        c.gl.framebufferRenderbuffer(c.gl.FRAMEBUFFER, attach_type, c.gl.RENDERBUFFER, null);\n    } else {\n        object = c._ns[object_id];\n        debug('Attaching {0} object {1} to framebuffer {2} for {3}'.format(object.object_type, object_id, dst_id, args[1]));\n        if (object.object_type == 'RenderBuffer') {\n            c.gl.bindRenderbuffer(c.gl.RENDERBUFFER, object.handle);\n            c.gl.framebufferRenderbuffer(c.gl.FRAMEBUFFER, attach_type, c.gl.RENDERBUFFER, object.handle);\n            c.gl.bindRenderbuffer(c.gl.RENDERBUFFER, null);\n        }\n        else if (object.object_type == 'Texture2D') {\n            // null or undefined\n            if (object.shape.length == 0) {\n                debug('Setting empty texture data to unset texture before attaching to framebuffer');\n                set_texture_data(c, object.handle, c.gl.TEXTURE_2D,\n                    c.gl[object.format], object.size[1], object.size[0], null);\n            }\n            // INFO: 0 is for mipmap level 0 (default) of the texture\n            c.gl.bindTexture(c.gl.TEXTURE_2D, object.handle);\n            c.gl.framebufferTexture2D(c.gl.FRAMEBUFFER, attach_type, c.gl.TEXTURE_2D, object.handle, 0);\n            c.gl.bindTexture(c.gl.TEXTURE_2D, null);\n        }\n    }\n    c._ns[dst_id].validated = false;\n    deactivate_framebuffer(c, dst_id);\n};\n\nglir.prototype.link = function(c, args) {\n    var program_handle = c._ns[args[0]].handle;\n    c.gl.linkProgram(program_handle);\n\n    if (!c.gl.getProgramParameter(program_handle, c.gl.LINK_STATUS))\n    {\n        console.warn(\"Could not initialise shaders on program '{0}'.\".format(program_handle));\n    }\n};\n\nglir.prototype.framebuffer = function(c, args) {\n    var framebuffer_id = args[0];\n    var bind = args[1];\n    var fb = c._ns[framebuffer_id];\n\n    if (bind) {\n        debug('Binding framebuffer {0}'.format(framebuffer_id));\n        activate_framebuffer(c, framebuffer_id);\n        if (!fb.validated) {\n            fb.validated = true;\n            validate_framebuffer(c);\n        }\n    }\n    else {\n        debug('Unbinding framebuffer {0}'.format(framebuffer_id));\n        deactivate_framebuffer(c, framebuffer_id);\n    }\n};\n\nglir.prototype.func = function(c, args) {\n    var name = args[0];\n    debug(\"Calling {0}({1}).\".format(name, args.slice(1)));\n\n    // Handle enums: replace strings by global GL variables.\n    for (var i = 1; i < args.length; i++) {\n        if (typeof args[i] === 'string') {\n            args[i] = parse_enum(c, args[i]);\n        }\n    }\n\n    var func = c.gl[name];\n    var func_args = args.slice(1);\n    func.apply(c.gl, func_args);\n};\n\nmodule.exports = new glir();\n\n},{\"./data.js\":1,\"./util.js\":7,\"./vispycanvas.js\":9}],4:[function(require,module,exports){\nvar glir = require('./gloo.glir.js');\n\nfunction init_webgl(c) {\n    // Get the DOM object, not the jQuery one.\n    var canvas = c.$el.get(0);\n    c.gl = canvas.getContext(\"webgl\") ||\n           canvas.getContext(\"experimental-webgl\");\n    var ext = c.gl.getExtension('OES_standard_derivatives') || c.gl.getExtension('MOZ_OES_standard_derivatives') || c.gl.getExtension('WEBKIT_OES_standard_derivatives');\n    if (ext === null) {\n        console.warn('Extension \\'OES_standard_derivatives\\' is not supported in this browser. Some features may not work as expected');\n    }\n    var ext = c.gl.getExtension('OES_element_index_uint') ||\n        c.gl.getExtension('MOZ_OES_element_index_uint') ||\n        c.gl.getExtension('WEBKIT_OES_element_index_uint');\n    if (ext === null) {\n        console.warn('Extension \\'OES_element_index_uint\\' is not supported in this browser. Some features may not work as expected');\n    }\n    var ext = c.gl.getExtension('OES_texture_float');\n    // ||\n    //     c.gl.getExtension('MOZ_OES_element_index_uint') ||\n    //     c.gl.getExtension('WEBKIT_OES_element_index_uint');\n    if (ext === null) {\n        console.warn('Extension \\'OES_texture_float\\' is not supported in this browser. Some features may not work as expected');\n    }\n\n    var ext = c.gl.getExtension('OES_texture_float_linear');\n    if (ext === null) {\n        console.warn('Extension \\'OES_texture_float_linear\\' is not supported in this browser. Some features may not work as expected');\n    }\n\n    // c.gl.getExtension('EXT_shader_texture_lod');\n}\n\n\n/* Creation of vispy.gloo */\nvar gloo = function() {\n    this.glir = glir;\n    // Constructor.\n\n};\n\ngloo.prototype.init = function(c) {\n    init_webgl(c);\n    this.glir.init(c);\n};\n\n\nmodule.exports = new gloo();\n\n},{\"./gloo.glir.js\":3}],5:[function(require,module,exports){\n/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)\n * Licensed under the MIT License (LICENSE.txt).\n *\n * Version: 3.1.12\n *\n * Requires: jQuery 1.2.2+\n */\n!function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):\"object\"==typeof exports?module.exports=a:a(jQuery)}(function(a){function b(b){var g=b||window.event,h=i.call(arguments,1),j=0,l=0,m=0,n=0,o=0,p=0;if(b=a.event.fix(g),b.type=\"mousewheel\",\"detail\"in g&&(m=-1*g.detail),\"wheelDelta\"in g&&(m=g.wheelDelta),\"wheelDeltaY\"in g&&(m=g.wheelDeltaY),\"wheelDeltaX\"in g&&(l=-1*g.wheelDeltaX),\"axis\"in g&&g.axis===g.HORIZONTAL_AXIS&&(l=-1*m,m=0),j=0===m?l:m,\"deltaY\"in g&&(m=-1*g.deltaY,j=m),\"deltaX\"in g&&(l=g.deltaX,0===m&&(j=-1*l)),0!==m||0!==l){if(1===g.deltaMode){var q=a.data(this,\"mousewheel-line-height\");j*=q,m*=q,l*=q}else if(2===g.deltaMode){var r=a.data(this,\"mousewheel-page-height\");j*=r,m*=r,l*=r}if(n=Math.max(Math.abs(m),Math.abs(l)),(!f||f>n)&&(f=n,d(g,n)&&(f/=40)),d(g,n)&&(j/=40,l/=40,m/=40),j=Math[j>=1?\"floor\":\"ceil\"](j/f),l=Math[l>=1?\"floor\":\"ceil\"](l/f),m=Math[m>=1?\"floor\":\"ceil\"](m/f),k.settings.normalizeOffset&&this.getBoundingClientRect){var s=this.getBoundingClientRect();o=b.clientX-s.left,p=b.clientY-s.top}return b.deltaX=l,b.deltaY=m,b.deltaFactor=f,b.offsetX=o,b.offsetY=p,b.deltaMode=0,h.unshift(b,j,l,m),e&&clearTimeout(e),e=setTimeout(c,200),(a.event.dispatch||a.event.handle).apply(this,h)}}function c(){f=null}function d(a,b){return k.settings.adjustOldDeltas&&\"mousewheel\"===a.type&&b%120===0}var e,f,g=[\"wheel\",\"mousewheel\",\"DOMMouseScroll\",\"MozMousePixelScroll\"],h=\"onwheel\"in document||document.documentMode>=9?[\"wheel\"]:[\"mousewheel\",\"DomMouseScroll\",\"MozMousePixelScroll\"],i=Array.prototype.slice;if(a.event.fixHooks)for(var j=g.length;j;)a.event.fixHooks[g[--j]]=a.event.mouseHooks;var k=a.event.special.mousewheel={version:\"3.1.12\",setup:function(){if(this.addEventListener)for(var c=h.length;c;)this.addEventListener(h[--c],b,!1);else this.onmousewheel=b;a.data(this,\"mousewheel-line-height\",k.getLineHeight(this)),a.data(this,\"mousewheel-page-height\",k.getPageHeight(this))},teardown:function(){if(this.removeEventListener)for(var c=h.length;c;)this.removeEventListener(h[--c],b,!1);else this.onmousewheel=null;a.removeData(this,\"mousewheel-line-height\"),a.removeData(this,\"mousewheel-page-height\")},getLineHeight:function(b){var c=a(b),d=c[\"offsetParent\"in a.fn?\"offsetParent\":\"parent\"]();return d.length||(d=a(\"body\")),parseInt(d.css(\"fontSize\"),10)||parseInt(c.css(\"fontSize\"),10)||16},getPageHeight:function(b){return a(b).height()},settings:{adjustOldDeltas:!0,normalizeOffset:!0}};a.fn.extend({mousewheel:function(a){return a?this.bind(\"mousewheel\",a):this.trigger(\"mousewheel\")},unmousewheel:function(a){return this.unbind(\"mousewheel\",a)}})});\n},{}],6:[function(require,module,exports){\n/*!\n* screenfull\n* v1.2.0 - 2014-04-29\n* (c) Sindre Sorhus; MIT License\n*/\n!function(){\"use strict\";var a=\"undefined\"!=typeof module&&module.exports,b=\"undefined\"!=typeof Element&&\"ALLOW_KEYBOARD_INPUT\"in Element,c=function(){for(var a,b,c=[[\"requestFullscreen\",\"exitFullscreen\",\"fullscreenElement\",\"fullscreenEnabled\",\"fullscreenchange\",\"fullscreenerror\"],[\"webkitRequestFullscreen\",\"webkitExitFullscreen\",\"webkitFullscreenElement\",\"webkitFullscreenEnabled\",\"webkitfullscreenchange\",\"webkitfullscreenerror\"],[\"webkitRequestFullScreen\",\"webkitCancelFullScreen\",\"webkitCurrentFullScreenElement\",\"webkitCancelFullScreen\",\"webkitfullscreenchange\",\"webkitfullscreenerror\"],[\"mozRequestFullScreen\",\"mozCancelFullScreen\",\"mozFullScreenElement\",\"mozFullScreenEnabled\",\"mozfullscreenchange\",\"mozfullscreenerror\"],[\"msRequestFullscreen\",\"msExitFullscreen\",\"msFullscreenElement\",\"msFullscreenEnabled\",\"MSFullscreenChange\",\"MSFullscreenError\"]],d=0,e=c.length,f={};e>d;d++)if(a=c[d],a&&a[1]in document){for(d=0,b=a.length;b>d;d++)f[c[0][d]]=a[d];return f}return!1}(),d={request:function(a){var d=c.requestFullscreen;a=a||document.documentElement,/5\\.1[\\.\\d]* Safari/.test(navigator.userAgent)?a[d]():a[d](b&&Element.ALLOW_KEYBOARD_INPUT)},exit:function(){document[c.exitFullscreen]()},toggle:function(a){this.isFullscreen?this.exit():this.request(a)},onchange:function(){},onerror:function(){},raw:c};return c?(Object.defineProperties(d,{isFullscreen:{get:function(){return!!document[c.fullscreenElement]}},element:{enumerable:!0,get:function(){return document[c.fullscreenElement]}},enabled:{enumerable:!0,get:function(){return!!document[c.fullscreenEnabled]}}}),document.addEventListener(c.fullscreenchange,function(a){d.onchange.call(d,a)}),document.addEventListener(c.fullscreenerror,function(a){d.onerror.call(d,a)}),void(a?module.exports=d:window.screenfull=d)):void(a?module.exports=!1:window.screenfull=!1)}();\n},{}],7:[function(require,module,exports){\nif (!String.prototype.format) {\n  String.prototype.format = function() {\n    var args = arguments;\n    return this.replace(/{(\\d+)}/g, function(match, number) {\n      return (typeof args[number] != 'undefined')\n        ? args[number]\n        : match;\n    });\n  };\n}\n\nif(typeof(String.prototype.trim) === \"undefined\")\n{\n    String.prototype.trim = function()\n    {\n        return String(this).replace(/^\\s+|\\s+$/g, '');\n    };\n}\n\nfunction is_array(x) {\n    return (Object.prototype.toString.call(x) === '[object Array]');\n}\n\nArray.prototype.equals = function (array) {\n    // if the other array is a falsy value, return\n    if (!array)\n        return false;\n\n    // compare lengths - can save a lot of time\n    if (this.length != array.length)\n        return false;\n\n    for (var i = 0, l=this.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (this[i] instanceof Array && array[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!this[i].equals(array[i]))\n                return false;\n        }\n        else if (this[i] != array[i]) {\n            // Warning - two different object instances will never be equal: {x:20} != {x:20}\n            return false;\n        }\n    }\n    return true;\n};\n\nif (typeof String.prototype.startsWith != 'function') {\n  String.prototype.startsWith = function (str){\n    return this.slice(0, str.length) == str;\n  };\n}\n\nwindow.VISPY_DEBUG = false;\nfunction debug(msg) {\n    if (window.VISPY_DEBUG){\n        console.debug(msg);\n    }\n}\n\nmodule.exports = {debug: debug};\n\n},{}],8:[function(require,module,exports){\nvar screenful = require(\"./lib/screenfull.min.js\");\nvar VispyCanvas = require('./vispycanvas.js');\nvar gloo = require('./gloo.js');\nvar events = require('./events.js');\nvar util = require('./util.js');\nvar data = require('./data.js');\nrequire(\"./lib/jquery.mousewheel.min.js\")($);\n\nvar Vispy = function() {\n    // Constructor of the Vispy library.\n    this.events = events;\n    this.gloo = gloo;\n    this._is_loop_running = false;\n    // List of canvases on the page.\n    this._canvases = [];\n};\n\nVispy.prototype.init = function(canvas_id) {\n    var canvas_el;\n    canvas_el = $(canvas_id);\n    // Initialize the canvas.\n    var canvas = new VispyCanvas(canvas_el);\n\n    canvas.deactivate_context_menu();\n\n    // Initialize events.\n    this.events.init(canvas);\n\n    // Initialize WebGL.\n    this.gloo.init(canvas);\n\n    // Register the canvas.\n    this.register(canvas);\n\n    return canvas;\n};\n\nVispy.prototype.register = function(canvas) {\n    /* Register a canvas. */\n    this._canvases.push(canvas);\n    // console.debug(\"Register canvas\", canvas);\n};\n\nVispy.prototype.unregister = function(canvas) {\n    /* Unregister a canvas. */\n    var index = this._canvases.indexOf(canvas);\n    if (index > -1) {\n        this._canvases.splice(index, 1);\n    }\n    // console.debug(\"Unregister canvas\", canvas);\n};\n\n\n/* Event loop */\nVispy.prototype.start_event_loop = function() {\n\n    // Do not start the event loop twice.\n    if (this._is_loop_running) return;\n\n    window.requestAnimFrame = (function(){\n          return  window.requestAnimationFrame       ||\n                  window.webkitRequestAnimationFrame ||\n                  window.mozRequestAnimationFrame    ||\n                  function(c){\n                    window.setTimeout(c, 1000. / 60.);\n                  };\n    })();\n\n    // \"that\" is the current Vispy instance.\n    var that = this;\n    (function animloop() {\n        that._request_id = requestAnimFrame(animloop);\n        try {\n            // Call event_tick() on all active canvases.\n            for (var i = 0; i < that._canvases.length; i++) {\n                that._canvases[i].event_tick();\n            }\n        }\n        catch(err) {\n            that.stop_event_loop();\n            throw (err);\n        }\n    })();\n\n    this._is_loop_running = true;\n    console.debug(\"Event loop started.\");\n};\n\nVispy.prototype.stop_event_loop = function() {\n    window.cancelAnimationFrame(this._request_id);\n    this._is_loop_running = false;\n    console.debug(\"Event loop stopped.\");\n};\n\n\nmodule.exports = new Vispy();\n\n},{\"./data.js\":1,\"./events.js\":2,\"./gloo.js\":4,\"./lib/jquery.mousewheel.min.js\":5,\"./lib/screenfull.min.js\":6,\"./util.js\":7,\"./vispycanvas.js\":9}],9:[function(require,module,exports){\n\nvar VispyCanvas = function ($el) {\n    this.$el = $el;\n};\n\nmodule.exports = VispyCanvas;\n\n},{}]},{},[8])(8)\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzY3JpcHRzL2RhdGEuanMiLCJzY3JpcHRzL2V2ZW50cy5qcyIsInNjcmlwdHMvZ2xvby5nbGlyLmpzIiwic2NyaXB0cy9nbG9vLmpzIiwic2NyaXB0cy9saWIvanF1ZXJ5Lm1vdXNld2hlZWwubWluLmpzIiwic2NyaXB0cy9saWIvc2NyZWVuZnVsbC5taW4uanMiLCJzY3JpcHRzL3V0aWwuanMiLCJzY3JpcHRzL3Zpc3B5LmpzIiwic2NyaXB0cy92aXNweWNhbnZhcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJmdW5jdGlvbiBkZWNvZGVfYmFzZTY0KGJhc2U2NCkge1xuICAgIHZhciBiaW5hcnlfc3RyaW5nID0gIHdpbmRvdy5hdG9iKGJhc2U2NCk7XG4gICAgdmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KCBsZW4gKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSAgICAgICAge1xuICAgICAgICB2YXIgYXNjaWkgPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGJ5dGVzW2ldID0gYXNjaWk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5idWZmZXI7XG59XG5cbi8vIE1hcHBpbmcgYmV0d2VlbiB1c2VyLWZyaWVuZGx5IGRhdGEgdHlwZSBzdHJpbmcsIGFuZCB0eXBlZCBhcnJheSBjbGFzc2VzLlxudmFyIF90eXBlZF9hcnJheV9tYXAgPSB7XG4gICAgJ2Zsb2F0MzInOiBGbG9hdDMyQXJyYXksXG4gICAgJ2ludDgnOiBJbnQ4QXJyYXksXG4gICAgJ2ludDE2JzogSW50MTZBcnJheSxcbiAgICAnaW50MzInOiBJbnQzMkFycmF5LFxuICAgICd1aW50OCc6IFVpbnQ4QXJyYXksXG4gICAgJ3VpbnQxNic6IFVpbnQxNkFycmF5LFxuICAgICd1aW50MzInOiBVaW50MzJBcnJheSxcbn07XG5cblxuZnVuY3Rpb24gdG9fYXJyYXlfYnVmZmVyKGRhdGEpIHtcbiAgICAvLyBSZXR1cm4gYSBUeXBlZEFycmF5IGZyb20gYSBKU09OIG9iamVjdCBkZXNjcmliaW5nIGEgZGF0YSBidWZmZXIuXG4gICAgLy8gc3RvcmFnZV90eXBlIGlzIG9uZSBvZiAnamF2YXNjcmlwdF9hcnJheScsICdqYXZhc2NyaXB0X3R5cGVkX2FycmF5JyxcbiAgICAvLyAnYmFzZTY0JywgJ3BuZydcbiAgICB2YXIgc3RvcmFnZV90eXBlID0gZGF0YVtcInN0b3JhZ2VfdHlwZVwiXTtcblxuICAgIC8vIGRhdGEgY2FuIGFsc28gYmUganVzdCBhIG5vcm1hbCB0eXBlZCBhcnJheSwgaW4gd2hpY2ggY2FzZSB3ZSBqdXN0IHJldHVyblxuICAgIC8vIHRoZSBhcmd1bWVudCB2YWx1ZS5cbiAgICBpZiAoc3RvcmFnZV90eXBlID09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YV90eXBlID0gZGF0YVtcImRhdGFfdHlwZVwiXTtcbiAgICB2YXIgY29udGVudHMgPSBkYXRhW1wiYnVmZmVyXCJdO1xuXG4gICAgaWYgKHN0b3JhZ2VfdHlwZSA9PSBcImphdmFzY3JpcHRfYXJyYXlcIikge1xuICAgICAgICAvLyBBIHJlZ3VsYXIgSmF2YVNjcmlwdCBhcnJheSwgdGhlIHR5cGUgbXVzdCBiZSBzcGVjaWZpZWQgaW4gJ2RhdGFfdHlwZScuXG4gICAgICAgIHJldHVybiBfdHlwZWRfYXJyYXlfbWFwW2RhdGFfdHlwZV0oY29udGVudHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdG9yYWdlX3R5cGUgPT0gXCJqYXZhc2NyaXB0X3R5cGVkX2FycmF5XCIgfHxcbiAgICAgICAgICAgICBzdG9yYWdlX3R5cGUgPT0gXCJhcnJheV9idWZmZXJcIikge1xuICAgICAgICAvLyBBIEphdmFTY3JpcHQgVHlwZWRhcnJheS5cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdG9yYWdlX3R5cGUgPT0gXCJiaW5hcnlcIikge1xuICAgICAgICAvLyBcImJpbmFyeVwiIG1lYW5zIHRoYXQgYmluYXJ5IFdlYlNvY2tldCBoYXMgYmVlbiB1c2VkXG4gICAgICAgIC8vIEEgSmF2YVNjcmlwdCBBcnJheUJ1ZmZlciByZWZlcmVuY2VkIGJ5IHRoZSBkYXRhIHZpZXcuXG4gICAgICAgIHJldHVybiBjb250ZW50cy5idWZmZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0b3JhZ2VfdHlwZSA9PSBcImJhc2U2NFwiKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGRlY29kZV9iYXNlNjQoY29udGVudHMpO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0b19hcnJheV9idWZmZXI6IHRvX2FycmF5X2J1ZmZlclxufTtcbiIsInZhciBWaXNweUNhbnZhcyA9IHJlcXVpcmUoJy4vdmlzcHljYW52YXMuanMnKTtcblxuLyogSW50ZXJuYWwgZnVuY3Rpb25zICovXG5mdW5jdGlvbiBnZXRfcG9zKGMsIGUpIHtcbiAgICB2YXIgcmVjdCA9IGMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFtlLmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICBlLmNsaWVudFkgLSByZWN0LnRvcF07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZV9wb3MoYywgcG9zKSB7XG4gICAgcmV0dXJuIFsyKnBvc1swXS9jLndpZHRoLTEsIDEtMipwb3NbMV0vYy5oZWlnaHRdO1xufVxuXG5mdW5jdGlvbiBnZXRfbW9kaWZpZXJzKGUpIHtcbiAgICB2YXIgbW9kaWZpZXJzID0gW107XG4gICAgaWYgKGUuYWx0S2V5KSBtb2RpZmllcnMucHVzaCgnYWx0Jyk7XG4gICAgaWYgKGUuY3RybEtleSkgbW9kaWZpZXJzLnB1c2goJ2N0cmwnKTtcbiAgICBpZiAoZS5tZXRhS2V5KSBtb2RpZmllcnMucHVzaCgnbWV0YScpO1xuICAgIGlmIChlLnNoaWZ0S2V5KSBtb2RpZmllcnMucHVzaCgnc2hpZnQnKTtcbiAgICByZXR1cm4gbW9kaWZpZXJzO1xufVxuXG5mdW5jdGlvbiBnZXRfa2V5X3RleHQoa2V5bnVtKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5bnVtKS50b1VwcGVyQ2FzZSgpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gX2dldF9rZXludW0oZSl7XG4gICAgaWYod2luZG93LmV2ZW50KXsgLy8gSUVcbiAgICAgICAgcmV0dXJuIGUua2V5Q29kZTtcbiAgICB9XG4gICAgZWxzZSBpZihlLndoaWNoKXsgLy8gTmV0c2NhcGUvRmlyZWZveC9PcGVyYVxuICAgICAgICByZXR1cm4gZS53aGljaDtcbiAgICB9XG59XG5cbnZhciBfa2V5X21hcCA9IHtcbiAgICA4OiAnQkFDS1NQQUNFJyxcbiAgICA5OiAnVEFCJyxcbiAgICAxMzogJ0VOVEVSJyxcbiAgICAxNjogJ1NISUZUJyxcbiAgICAxNzogJ0NPTlRST0wnLFxuICAgIDE4OiAnQUxUJyxcbiAgICAyNzogJ0VTQ0FQRScsXG4gICAgMzI6ICdTUEFDRScsXG4gICAgMzM6ICdQQUdFVVAnLFxuICAgIDM0OiAnUEFHRURPV04nLFxuICAgIDM1OiAnRU5EJyxcbiAgICAzNjogJ0hPTUUnLFxuICAgIDM3OiAnTEVGVCcsXG4gICAgMzg6ICdVUCcsXG4gICAgMzk6ICdSSUdIVCcsXG4gICAgNDA6ICdET1dOJyxcbiAgICA0NTogJ0lOU0VSVCcsXG4gICAgNDY6ICdERUxFVEUnLFxuICAgIDkxOiAnTUVUQScsXG4gICAgOTI6ICdNRVRBJyxcbiAgICA5NjogJzAnLFxuICAgIDk3OiAnMScsXG4gICAgOTg6ICcyJyxcbiAgICA5OTogJzMnLFxuICAgIDEwMDogJzQnLFxuICAgIDEwMTogJzUnLFxuICAgIDEwMjogJzYnLFxuICAgIDEwMzogJzcnLFxuICAgIDEwNDogJzgnLFxuICAgIDEwNTogJzknLFxuICAgIDEwNjogJyonLFxuICAgIDEwNzogJysnLFxuICAgIDEwOTogJy0nLFxuICAgIDExMDogJy4nLFxuICAgIDExMTogJy8nLFxuICAgIDExMjogJ0YxJyxcbiAgICAxMTM6ICdGMicsXG4gICAgMTE0OiAnRjMnLFxuICAgIDExNTogJ0Y0JyxcbiAgICAxMTY6ICdGNScsXG4gICAgMTE3OiAnRjYnLFxuICAgIDExODogJ0Y3JyxcbiAgICAxMTk6ICdGOCcsXG4gICAgMTIwOiAnRjknLFxuICAgIDEyMTogJ0YxMCcsXG4gICAgMTIyOiAnRjExJyxcbiAgICAxMjM6ICdGMTInLFxuICAgIDE4NjogJzsnLFxuICAgIDE4NzogJz0nLFxuICAgIDE4ODogJywnLFxuICAgIDE4OTogJy0nLFxuICAgIDE5MDogJy4nLFxuICAgIDE5MTogJy8nLFxuICAgIDE5MjogJ2AnLFxuICAgIDIxOTogJ1snLFxuICAgIDIyMDogJ1xcXFwnLFxuICAgIDIyMTogJ10nLFxuICAgIDIyMjogJ1xcJycsXG59O1xuZnVuY3Rpb24gZ2V0X2tleV9jb2RlKGUpe1xuICAgIC8vIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGtleS4gSXQgd2lsbCBiZSBpbnRlcnByZXRlZCBieVxuICAgIC8vIFZpc3B5LlxuICAgIHZhciBrZXludW0gPSBfZ2V0X2tleW51bShlKTtcbiAgICB2YXIga2V5X2NvZGUgPSBfa2V5X21hcFtrZXludW1dO1xuICAgIGlmIChrZXlfY29kZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5X2NvZGUgPSBnZXRfa2V5X3RleHQoa2V5bnVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleV9jb2RlO1xufVxuXG5cbi8qIEV2ZW50IGdlbmVyYXRpb24gKi9cbnZhciBfYnV0dG9uX21hcCA9IHtcbiAgICAwOiAxLCAgIC8vIGxlZnRcbiAgICAyOiAyLCAgIC8vIHJpZ2h0XG4gICAgMTogMywgICAvLyBtaWRkbGVcbn07XG5mdW5jdGlvbiBnZW5fbW91c2VfZXZlbnQoYywgZSwgdHlwZSkge1xuICAgIGlmIChjLl9ldmVudGluZm8uaXNfYnV0dG9uX3ByZXNzZWQpXG4gICAgICAgIHZhciBidXR0b24gPSBfYnV0dG9uX21hcFtlLmJ1dHRvbl07XG4gICAgZWxzZVxuICAgICAgICBidXR0b24gPSBudWxsO1xuICAgIHZhciBwb3MgPSBnZXRfcG9zKGMuJGVsLmdldCgwKSwgZSk7XG4gICAgdmFyIG1vZGlmaWVycyA9IGdldF9tb2RpZmllcnMoZSk7XG4gICAgdmFyIHByZXNzX2V2ZW50ID0gYy5fZXZlbnRpbmZvLnByZXNzX2V2ZW50O1xuICAgIHZhciBsYXN0X2V2ZW50ID0gYy5fZXZlbnRpbmZvLmxhc3RfZXZlbnQ7XG4gICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICdwb3MnOiBwb3MsXG4gICAgICAgICdidXR0b24nOiBidXR0b24sXG4gICAgICAgICdpc19kcmFnZ2luZyc6IHByZXNzX2V2ZW50ICE9IG51bGwsXG4gICAgICAgICdtb2RpZmllcnMnOiBtb2RpZmllcnMsXG4gICAgICAgICdkZWx0YSc6IG51bGwsXG4gICAgICAgICdwcmVzc19ldmVudCc6IHByZXNzX2V2ZW50LFxuXG4gICAgICAgICdsYXN0X2V2ZW50JzogbnVsbCwgIC8vIEhBQ0s6IGRpc2FibGVkIHRvIGF2b2lkIHJlY3Vyc2lvbiBwcm9ibGVtc1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGdlbl9yZXNpemVfZXZlbnQoYywgc2l6ZSkge1xuICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgJ3R5cGUnOiAncmVzaXplJyxcbiAgICAgICAgJ3NpemUnOiBzaXplLFxuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGdlbl9wYWludF9ldmVudChjKSB7XG4gICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAndHlwZSc6ICdwYWludCcsXG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gZ2VuX2luaXRpYWxpemVfZXZlbnQoYykge1xuICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgJ3R5cGUnOiAnaW5pdGlhbGl6ZScsXG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gZ2VuX2tleV9ldmVudChjLCBlLCB0eXBlKSB7XG4gICAgdmFyIG1vZGlmaWVycyA9IGdldF9tb2RpZmllcnMoZSk7XG4gICAgdmFyIGxhc3RfZXZlbnQgPSBjLl9ldmVudGluZm8ubGFzdF9ldmVudDtcbiAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgJ21vZGlmaWVycyc6IG1vZGlmaWVycyxcbiAgICAgICAgJ2tleV9jb2RlJzogZ2V0X2tleV9jb2RlKGUpLFxuICAgICAgICAnbGFzdF9ldmVudCc6IG51bGwsICAvLyBIQUNLOiBkaXNhYmxlZCB0byBhdm9pZCByZWN1cnNpb24gcHJvYmxlbXNcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xufVxuXG5cblxuLyogSW50ZXJuYWwgY2FsbGJhY2sgZnVuY3Rpb25zICovXG5WaXNweUNhbnZhcy5wcm90b3R5cGUuX21vdXNlX3ByZXNzID0gZnVuY3Rpb24oZSkgeyB9O1xuVmlzcHlDYW52YXMucHJvdG90eXBlLl9tb3VzZV9yZWxlYXNlID0gZnVuY3Rpb24oZSkgeyB9O1xuVmlzcHlDYW52YXMucHJvdG90eXBlLl9tb3VzZV9tb3ZlID0gZnVuY3Rpb24oZSkgeyB9O1xuVmlzcHlDYW52YXMucHJvdG90eXBlLl9tb3VzZV93aGVlbCA9IGZ1bmN0aW9uKGUpIHsgfTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5fbW91c2VfY2xpY2sgPSBmdW5jdGlvbihlKSB7IH07XG5WaXNweUNhbnZhcy5wcm90b3R5cGUuX21vdXNlX2RibGNsaWNrID0gZnVuY3Rpb24oZSkgeyB9O1xuXG5WaXNweUNhbnZhcy5wcm90b3R5cGUuX2tleV9wcmVzcyA9IGZ1bmN0aW9uKGUpIHsgfTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5fa2V5X3JlbGVhc2UgPSBmdW5jdGlvbihlKSB7IH07XG5cblZpc3B5Q2FudmFzLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGUpIHsgfTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5fcmVzaXplID0gZnVuY3Rpb24oZSkgeyB9O1xuVmlzcHlDYW52YXMucHJvdG90eXBlLl9wYWludCA9IGZ1bmN0aW9uKGUpIHsgfTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5fZXZlbnRfdGljayA9IGZ1bmN0aW9uKGUpIHsgfTtcblxuXG5cbi8qIFJlZ2lzdGVyaW5nIGhhbmRsZXJzICovXG5WaXNweUNhbnZhcy5wcm90b3R5cGUub25fbW91c2VfcHJlc3MgPSBmdW5jdGlvbihmKSB7XG4gICAgdGhpcy5fbW91c2VfcHJlc3MgPSBmO1xufTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5vbl9tb3VzZV9yZWxlYXNlID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMuX21vdXNlX3JlbGVhc2UgPSBmO1xufTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5vbl9tb3VzZV9tb3ZlID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMuX21vdXNlX21vdmUgPSBmO1xufTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5vbl9tb3VzZV93aGVlbCA9IGZ1bmN0aW9uKGYpIHtcbiAgICB0aGlzLl9tb3VzZV93aGVlbCA9IGY7XG59O1xuVmlzcHlDYW52YXMucHJvdG90eXBlLm9uX21vdXNlX2RibGNsaWNrID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMuX21vdXNlX2RibGNsaWNrID0gZjtcbn07XG5WaXNweUNhbnZhcy5wcm90b3R5cGUub25fa2V5X3ByZXNzID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMuX2tleV9wcmVzcyA9IGY7XG59O1xuVmlzcHlDYW52YXMucHJvdG90eXBlLm9uX2tleV9yZWxlYXNlID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMuX2tleV9yZWxlYXNlID0gZjtcbn07XG5WaXNweUNhbnZhcy5wcm90b3R5cGUub25faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplID0gZjtcbn07XG5WaXNweUNhbnZhcy5wcm90b3R5cGUub25fcmVzaXplID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMuX3Jlc2l6ZSA9IGY7XG59O1xuVmlzcHlDYW52YXMucHJvdG90eXBlLm9uX3BhaW50ID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMuX3BhaW50ID0gZjtcbn07XG5WaXNweUNhbnZhcy5wcm90b3R5cGUub25fZXZlbnRfdGljayA9IGZ1bmN0aW9uKGYpIHtcbiAgICB0aGlzLl9ldmVudF90aWNrID0gZjtcbn07XG5cblxuVmlzcHlDYW52YXMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSBnZW5faW5pdGlhbGl6ZV9ldmVudCh0aGlzKTtcbiAgICB0aGlzLl9zZXRfc2l6ZSgpO1xuICAgIHRoaXMuX2luaXRpYWxpemUoZXZlbnQpO1xufTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS5fc2V0X3NpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgaWYgKHNpemUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNpemUgPSBbdGhpcy4kZWwud2lkdGgoKSwgdGhpcy4kZWwuaGVpZ2h0KCldO1xuICAgIH1cbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMud2lkdGggPSBzaXplWzBdO1xuICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZVsxXTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cblZpc3B5Q2FudmFzLnByb3RvdHlwZS5wYWludCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIEFkZCBhIHBhaW50IGV2ZW50IGluIHRoZSBldmVudCBxdWV1ZS4gKi9cbiAgICB2YXIgZXZlbnQgPSBnZW5fcGFpbnRfZXZlbnQodGhpcyk7XG4gICAgdGhpcy5ldmVudF9xdWV1ZS5hcHBlbmQoZXZlbnQpO1xufTtcblZpc3B5Q2FudmFzLnByb3RvdHlwZS51cGRhdGUgPSBWaXNweUNhbnZhcy5wcm90b3R5cGUucGFpbnQ7XG5WaXNweUNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHNpemUgPSB0aGlzLl9zZXRfc2l6ZShzaXplKTtcbiAgICB2YXIgZXZlbnQgPSBnZW5fcmVzaXplX2V2ZW50KHRoaXMsIHNpemUpO1xuICAgIHRoaXMuZ2wuY2FudmFzLndpZHRoID0gc2l6ZVswXTtcbiAgICB0aGlzLmdsLmNhbnZhcy5oZWlnaHQgPSBzaXplWzFdO1xuICAgIC8vIFB1dCB0aGUgcmVzaXplIGV2ZW50IGluIHRoZSBxdWV1ZS5cbiAgICB0aGlzLmV2ZW50X3F1ZXVlLmFwcGVuZChldmVudCk7XG4gICAgdGhpcy5fcmVzaXplKGV2ZW50KTtcbn07XG5cblZpc3B5Q2FudmFzLnByb3RvdHlwZS5ldmVudF90aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZXZlbnRfdGljaygpO1xuICAgIHZhciBuY29tbWFuZHMgPSB0aGlzLmV4ZWN1dGVfcGVuZGluZ19jb21tYW5kcygpO1xuICAgIGlmIChuY29tbWFuZHMgPiAwKSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IDEgR0xJUiBjb21tYW5kIGhhcyBiZWVuIGV4ZWN1dGVkIGhlcmUuXG4gICAgICAgIC8vIFdlIGNhbGwgdGhlIG9uX3BhaW50IGNhbGxiYWNrIGZ1bmN0aW9uIGhlcmUuXG4gICAgICAgIHZhciBldmVudCA9IGdlbl9wYWludF9ldmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFpbnQoZXZlbnQpO1xuICAgIH1cbn07XG5cblZpc3B5Q2FudmFzLnByb3RvdHlwZS5pc19mdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChzY3JlZW5mdWxsLmVuYWJsZWQpICYgKHNjcmVlbmZ1bGwuaXNGdWxsc2NyZWVuKTtcbn07XG5cblZpc3B5Q2FudmFzLnByb3RvdHlwZS50b2dnbGVfZnVsbHNjcmVlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzY3JlZW5mdWxsLmVuYWJsZWQpIHtcbiAgICAgICAgaWYoc2NyZWVuZnVsbC5pc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHNjcmVlbmZ1bGwuZXhpdCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5fc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC53aWR0aChcIjEwMCVcIikuaGVpZ2h0KFwiMTAwJVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSBbdGhpcy4kZWwud2lkdGgoKSwgdGhpcy4kZWwuaGVpZ2h0KCldO1xuICAgICAgICAgICAgc2NyZWVuZnVsbC5yZXF1ZXN0KHRoaXMuJGVsWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKFtzY3JlZW4ud2lkdGgsIHNjcmVlbi5oZWlnaHRdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZpc3B5Q2FudmFzLnByb3RvdHlwZS5kZWFjdGl2YXRlX2NvbnRleHRfbWVudSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbn1cblxuVmlzcHlDYW52YXMucHJvdG90eXBlLnJlc2l6YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLiRlbC5yZXNpemFibGUoe1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuICAgICAgICAgICAgdGhhdC5yZXNpemUoW3VpLnNpemUud2lkdGgsIHVpLnNpemUuaGVpZ2h0XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyogRXZlbnQgcXVldWUgcHJvdG90eXBlICovXG5mdW5jdGlvbiBfZXZlbnRzX2Nhbl9iZV9jb21iaW5lZChlMSwgZTIpIHtcbiAgICAvLyBSZXR1cm4gdGhlIGxpc3Qgb2YgcHJvcGVydGllcyB0byBjb3B5IHRvIGUyLlxuICAgIC8vIFRoZSByZXR1cm5lZCBsaXN0IGlzIG5vbiBlbXB0eSBpZiB0aGUgdHdvIGV2ZW50cyBjYW4gYmUgY29tYmluZWQuXG4gICAgLy8gSXQgaXMgZW1wdHkgaWYgdGhlIHR3byBldmVudHMgY2Fubm90IGJlIGNvbWJpbmVkLlxuICAgIHZhciB0eXBlID0gZTEudHlwZTtcbiAgICBpZiAodHlwZSA9PSBlMi50eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09ICdtb3VzZV9tb3ZlJykge1xuICAgICAgICAgICAgaWYgKChlMS5idXR0b24gPT0gZTIuYnV0dG9uKSAmXG4gICAgICAgICAgICAgICAgKGUxLmlzX2RyYWdnaW5nID09IGUyLmlzX2RyYWdnaW5nKSAmXG4gICAgICAgICAgICAgICAgKGUxLm1vZGlmaWVycy5lcXVhbHMoZTIubW9kaWZpZXJzKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydwb3MnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIEV2ZW50UXVldWUobWF4bGVuKSB7XG4gICAgaWYgKG1heGxlbiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWF4bGVuID0gMTAwO1xuICAgIH1cbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMubWF4bGVuID0gbWF4bGVuO1xufVxuRXZlbnRRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xufVxuRXZlbnRRdWV1ZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oZSwgY29tcHJlc3MpIHtcbiAgICAvLyBDb21wcmVzc2lvbiBhbGxvd3Mgc2V2ZXJhbCBzaW1pbGFyIGNvbnNlY3V0aXZlIGV2ZW50cyB0byBiZSBtZXJnZWRcbiAgICAvLyBpbnRvIGEgc2luZ2xlIGV2ZW50LCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAobm90YWJseSwgJ21vdXNlX21vdmUnKS5cbiAgICB2YXIgYWRkX3RvX3F1ZXVlID0gdHJ1ZTtcbiAgICBpZiAoY29tcHJlc3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXByZXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICAgIC8vIElmIHRoZSBldmVudCB0eXBlIGlzIGlkZW50aWNhbCB0byB0aGUgbGFzdCBldmVudCwgd2VcbiAgICAgICAgLy8ganVzdCB1cGRhdGUgdGhlIHBhcmFtZXRlcnMgaW5zdGVhZCBvZiBwdXNoaW5nIGEgbmV3IGV2ZW50LlxuICAgICAgICB2YXIgbGFzdF9ldmVudCA9IHRoaXMuX3F1ZXVlW3RoaXMuX3F1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdF9ldmVudCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGlzdCBvciBwcm9wZXJ0aWVzIHRvIGNvbWJpbmUuXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBfZXZlbnRzX2Nhbl9iZV9jb21iaW5lZChlLCBsYXN0X2V2ZW50KTtcbiAgICAgICAgICAgIC8vIENvbWJpbmUgdGhlIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVbdGhpcy5fcXVldWUubGVuZ3RoIC0gMV1bcHJvcF0gPSBlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIG5vIG5lZWQgdG8gYWRkIHRoZSBuZXcgZXZlbnQgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgbGFzdCBleGlzdGluZyBldmVudCBjYW4gYmUgdXBkYXRlZCAoXCJjb21iaW5lZFwiXG4gICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgbmV3IG9uZSkuXG4gICAgICAgICAgICAgICAgYWRkX3RvX3F1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFkZF90b19xdWV1ZSkge1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGUpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIG9sZGVzdCBlbGVtZW50IGlmIHRoZSBxdWV1ZSBpcyBsb25nZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHNpZGUuXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4bGVuKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSByZW1vdmVkIGV2ZW50IGluIG9yZGVyIHRvIGNsZWFuIHRoZSBHQy5cbiAgICAgICAgdGhpcy5fcXVldWVbMF0ubGFzdF9ldmVudCA9IG51bGw7XG4gICAgfVxufVxuRXZlbnRRdWV1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50UXVldWUucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aDsgfSxcbn0pO1xuXG5cbi8qIENhbnZhcyBpbml0aWFsaXphdGlvbiAqL1xuZnVuY3Rpb24gaW5pdF9hcHAoYykge1xuXG4gICAgLy8gR2VuZXJhdGUgYSByZXNpemUgZXZlbnQgd2hlbiB0aGUgdXNlciByZXNpemVzIHRoZSBjYW52YXMgd2l0aFxuICAgIC8vIGpRdWVyeSByZXNpemFibGUuXG4gICAgYy4kZWwucmVzaXplKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGMucmVzaXplKFtlLndpZHRoKCksIGUuaGVpZ2h0KCldKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBjLmV2ZW50X3F1ZXVlID0gbmV3IEV2ZW50UXVldWUoKTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IHN0b3JlcyBzb21lIHN0YXRlIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aGUgYXBwcm9wcmlhdGVcbiAgICAvLyBldmVudHMuXG4gICAgYy5fZXZlbnRpbmZvID0ge1xuICAgICAgICAndHlwZSc6IG51bGwsXG4gICAgICAgICdwb3MnOiBudWxsLFxuICAgICAgICAnYnV0dG9uJzogbnVsbCxcbiAgICAgICAgJ2lzX2RyYWdnaW5nJzogbnVsbCxcbiAgICAgICAgJ2tleSc6IG51bGwsXG4gICAgICAgICdtb2RpZmllcnMnOiBbXSxcbiAgICAgICAgJ3ByZXNzX2V2ZW50JzogbnVsbCxcbiAgICAgICAgJ2xhc3RfZXZlbnQnOiBudWxsLFxuICAgICAgICAnZGVsdGEnOiBudWxsLFxuICAgIH1cblxuICAgIC8vIEhBQ0s6IGJvb2xlYW4gc3RhdGluZyB3aGV0aGVyIGEgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQuXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBlLmJ1dHRvbj09MCBpbiB0d28gY2FzZXM6IG5vXG4gICAgLy8gYnV0dG9uIGlzIHByZXNzZWQsIG9yIHRoZSBsZWZ0IGJ1dHRvbiBpcyBwcmVzc2VkLlxuICAgIGMuX2V2ZW50aW5mby5pc19idXR0b25fcHJlc3NlZCA9IDA7XG5cbiAgICBjLiRlbC5tb3VzZW1vdmUoZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBnZW5fbW91c2VfZXZlbnQoYywgZSwgJ21vdXNlX21vdmUnKTtcblxuICAgICAgICAvLyBWaXNweSBjYWxsYmFja3MuXG4gICAgICAgIGMuX21vdXNlX21vdmUoZXZlbnQpO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZXZlbnQuXG4gICAgICAgIC8vIGMuX2V2ZW50aW5mby5sYXN0X2V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGMuZXZlbnRfcXVldWUuYXBwZW5kKGV2ZW50KTtcbiAgICB9KTtcbiAgICBjLiRlbC5tb3VzZWRvd24oZnVuY3Rpb24oZSkge1xuICAgICAgICArK2MuX2V2ZW50aW5mby5pc19idXR0b25fcHJlc3NlZDtcbiAgICAgICAgdmFyIGV2ZW50ID0gZ2VuX21vdXNlX2V2ZW50KGMsIGUsICdtb3VzZV9wcmVzcycpO1xuXG4gICAgICAgIC8vIFZpc3B5IGNhbGxiYWNrcy5cbiAgICAgICAgYy5fbW91c2VfcHJlc3MoZXZlbnQpO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgcHJlc3MgZXZlbnQuXG4gICAgICAgIGMuX2V2ZW50aW5mby5wcmVzc19ldmVudCA9IGV2ZW50O1xuICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGV2ZW50LlxuICAgICAgICAvLyBjLl9ldmVudGluZm8ubGFzdF9ldmVudCA9IGV2ZW50O1xuICAgICAgICBjLmV2ZW50X3F1ZXVlLmFwcGVuZChldmVudCk7XG4gICAgfSk7XG4gICAgYy4kZWwubW91c2V1cChmdW5jdGlvbihlKSB7XG4gICAgICAgIC0tYy5fZXZlbnRpbmZvLmlzX2J1dHRvbl9wcmVzc2VkO1xuICAgICAgICB2YXIgZXZlbnQgPSBnZW5fbW91c2VfZXZlbnQoYywgZSwgJ21vdXNlX3JlbGVhc2UnKTtcblxuICAgICAgICAvLyBWaXNweSBjYWxsYmFja3MuXG4gICAgICAgIGMuX21vdXNlX3JlbGVhc2UoZXZlbnQpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBsYXN0IHByZXNzIGV2ZW50LlxuICAgICAgICBjLl9ldmVudGluZm8ucHJlc3NfZXZlbnQgPSBudWxsO1xuICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGV2ZW50LlxuICAgICAgICAvLyBjLl9ldmVudGluZm8ubGFzdF9ldmVudCA9IGV2ZW50O1xuICAgICAgICBjLmV2ZW50X3F1ZXVlLmFwcGVuZChldmVudCk7XG4gICAgfSk7XG4gICAgYy4kZWwuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBSZXNldCB0aGUgbGFzdCBwcmVzcyBldmVudC5cbiAgICAgICAgYy5fZXZlbnRpbmZvLnByZXNzX2V2ZW50ID0gbnVsbDtcbiAgICB9KTtcbiAgICBjLiRlbC5kYmxjbGljayhmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGxhc3QgcHJlc3MgZXZlbnQuXG4gICAgICAgIGMuX2V2ZW50aW5mby5wcmVzc19ldmVudCA9IG51bGw7XG4gICAgfSk7XG4gICAgLy8gVGhpcyByZXF1aXJlcyB0aGUgbW91c2Ugd2hlZWwganF1ZXJ5IHBsdWdpbi5cbiAgICBpZiAoYy4kZWwubW91c2V3aGVlbCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYy4kZWwubW91c2V3aGVlbChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBnZW5fbW91c2VfZXZlbnQoYywgZSwgJ21vdXNlX3doZWVsJyk7XG4gICAgICAgICAgICBldmVudC5kZWx0YSA9IFtlLmRlbHRhWCAqIGUuZGVsdGFGYWN0b3IgKiAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRlbHRhWSAqIGUuZGVsdGFGYWN0b3IgKiAuMDFdO1xuXG4gICAgICAgICAgICAvLyBWaXNweSBjYWxsYmFja3MuXG4gICAgICAgICAgICBjLl9tb3VzZV93aGVlbChldmVudCk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZXZlbnQuXG4gICAgICAgICAgICAvLyBjLl9ldmVudGluZm8ubGFzdF9ldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgYy5ldmVudF9xdWV1ZS5hcHBlbmQoZXZlbnQpO1xuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjLiRlbC5rZXlkb3duKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZ2VuX2tleV9ldmVudChjLCBlLCAna2V5X3ByZXNzJyk7XG5cbiAgICAgICAgLy8gVmlzcHkgY2FsbGJhY2tzLlxuICAgICAgICBjLl9rZXlfcHJlc3MoZXZlbnQpO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZXZlbnQuXG4gICAgICAgIC8vIGMuX2V2ZW50aW5mby5sYXN0X2V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGMuZXZlbnRfcXVldWUuYXBwZW5kKGV2ZW50KTtcbiAgICB9KTtcbiAgICBjLiRlbC5rZXl1cChmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBldmVudCA9IGdlbl9rZXlfZXZlbnQoYywgZSwgJ2tleV9yZWxlYXNlJyk7XG5cbiAgICAgICAgLy8gVmlzcHkgY2FsbGJhY2tzLlxuICAgICAgICBjLl9rZXlfcmVsZWFzZShldmVudCk7XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBldmVudC5cbiAgICAgICAgLy8gYy5fZXZlbnRpbmZvLmxhc3RfZXZlbnQgPSBldmVudDtcbiAgICAgICAgYy5ldmVudF9xdWV1ZS5hcHBlbmQoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgYy4kZWwubW91c2VvdXQoZnVuY3Rpb24oZSkge1xuICAgIH0pO1xufVxuXG5cbi8qIENyZWF0aW9uIG9mIHZpc3B5LmV2ZW50cyAqL1xudmFyIGV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIENvbnN0cnVjdG9yLlxuXG59O1xuXG5ldmVudHMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihjKSB7XG4gICAgaW5pdF9hcHAoYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBldmVudHMoKTtcbiIsInZhciBWaXNweUNhbnZhcyA9IHJlcXVpcmUoJy4vdmlzcHljYW52YXMuanMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsLmpzJyk7XG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vZGF0YS5qcycpO1xuXG52YXIgZGVidWcgPSB1dGlsLmRlYnVnO1xudmFyIHRvX2FycmF5X2J1ZmZlciA9IGRhdGEudG9fYXJyYXlfYnVmZmVyO1xudmFyIEpVU1RfREVMRVRFRCA9ICdKVVNUX0RFTEVURUQnO1xuXG4vKiBXZWJHTCB1dGlsaXR5IGZ1bmN0aW9ucyAqL1xuZnVuY3Rpb24gdmlld3BvcnQoYykge1xuICAgIGMuZ2wudmlld3BvcnQoMCwgMCwgYy53aWR0aCgpLCBjLmhlaWdodCgpKTtcbn1cblxuZnVuY3Rpb24gY2xlYXIoYywgY29sb3IpIHtcbiAgICBjLmdsLmNsZWFyQ29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgY29sb3JbM10pO1xuICAgIGMuZ2wuY2xlYXIoYy5nbC5DT0xPUl9CVUZGRVJfQklUKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZV9zaGFkZXIoYywgc2hhZGVyLCBzb3VyY2UpIHtcbiAgICAvLyBUT0RPOiBDb252ZXJ0IGRlc2t0b3AgR0xTTCBjb2RlIGlmIG5lZWRlZFxuICAgIGNvbnNvbGUubG9nKHR5cGVvZiBzb3VyY2UpO1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBhc3N1bWUgd2UgaGF2ZSBhIGJ1ZmZlclxuICAgICAgICBzb3VyY2UgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHNvdXJjZSkpO1xuXG4gICAgfVxuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC9cXFxcbi9nLCBcIlxcblwiKTtcblxuICAgIGMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICBjLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghYy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBjLmdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hdHRyaWJ1dGUoYywgcHJvZ3JhbSwgbmFtZSkge1xuICAgIHZhciBhdHRyaWJ1dGVfaGFuZGxlID0gYy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICByZXR1cm4gYXR0cmlidXRlX2hhbmRsZTtcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVfYXR0cmlidXRlKGMsIGF0dHJpYnV0ZV9oYW5kbGUsIHZib19pZCwgdHlwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICAvLyBhdHRyaWJ1dGVfaGFuZGxlOiBhdHRyaWJ1dGUgaGFuZGxlXG4gICAgLy8gdmJvX2lkXG4gICAgLy8gdHlwZTogZmxvYXQsIHZlYzMsIGV0Yy5cbiAgICAvLyBzdHJpZGU6IDAgYnkgZGVmYXVsdFxuICAgIC8vIG9mZnNldDogMCBieSBkZWZhdWx0XG4gICAgdmFyIF9hdHRyaWJ1dGVfaW5mbyA9IGdldF9hdHRyaWJ1dGVfaW5mbyh0eXBlKTtcbiAgICB2YXIgYXR0cmlidXRlX3R5cGUgPSBfYXR0cmlidXRlX2luZm9bMF07ICAvLyBGTE9BVCwgSU5UIG9yIEJPT0xcbiAgICB2YXIgbmRpbSA9IF9hdHRyaWJ1dGVfaW5mb1sxXTsgLy8gMSwgMiwgMyBvciA0XG5cbiAgICBfdmJvX2luZm8gPSBjLl9uc1t2Ym9faWRdO1xuICAgIHZhciB2Ym9faGFuZGxlID0gX3Zib19pbmZvLmhhbmRsZTtcblxuICAgIGMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlX2hhbmRsZSk7XG4gICAgYy5nbC5iaW5kQnVmZmVyKGMuZ2wuQVJSQVlfQlVGRkVSLCB2Ym9faGFuZGxlKTtcbiAgICBjLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmlidXRlX2hhbmRsZSwgbmRpbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nbFthdHRyaWJ1dGVfdHlwZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLCBzdHJpZGUsIG9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVfYXR0cmlidXRlKGMsIGF0dHJpYnV0ZV9oYW5kbGUpIHtcbiAgICAvLyBjLmdsLmJpbmRCdWZmZXIoYy5nbC5HTF9BUlJBWV9CVUZGRVIsIDApO1xuICAgIGMuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZV9oYW5kbGUpO1xufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZV90ZXh0dXJlKGMsIHRleHR1cmVfaGFuZGxlLCBzYW1wbGVyX2hhbmRsZSwgdGV4dHVyZV9pbmRleCkge1xuICAgIGlmICh0ZXh0dXJlX2hhbmRsZSA9PT0gSlVTVF9ERUxFVEVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYy5nbC5hY3RpdmVUZXh0dXJlKGMuZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlX2luZGV4KTtcbiAgICBjLmdsLmJpbmRUZXh0dXJlKGMuZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZV9oYW5kbGUpO1xuICAgIC8vIGMuZ2wudW5pZm9ybTFpKHNhbXBsZXJfaGFuZGxlLCAwKTtcbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZV90ZXh0dXJlKGMsIHRleHR1cmVfaGFuZGxlLCBzYW1wbGVyX2hhbmRsZSwgdGV4dHVyZV9pbmRleCkge1xuICAgIGMuZ2wuYWN0aXZlVGV4dHVyZShjLmdsLlRFWFRVUkUwICsgdGV4dHVyZV9pbmRleCk7XG4gICAgYy5nbC5iaW5kVGV4dHVyZShjLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xufVxuXG5mdW5jdGlvbiBfZ2V0X2FsaWdubWVudCh3aWR0aCkge1xuICAgIC8qIERldGVybWluZXMgYSB0ZXh0dXJlcyBieXRlIGFsaWdubWVudC5cblxuICAgIElmIHRoZSB3aWR0aCBpc24ndCBhIHBvd2VyIG9mIDJcbiAgICB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYnl0ZSBhbGlnbm1lbnQgb2YgdGhlIGltYWdlLlxuICAgIFRoZSBpbWFnZSBoZWlnaHQgaXMgdW5pbXBvcnRhbnRcblxuICAgIHd3dy5vcGVuZ2wub3JnL3dpa2kvQ29tbW9uX01pc3Rha2VzI1RleHR1cmVfdXBsb2FkX2FuZF9waXhlbF9yZWFkc1xuXG4gICAgd2Uga25vdyB0aGUgYWxpZ25tZW50IGlzIGFwcHJvcHJpYXRlXG4gICAgaWYgd2UgY2FuIGRpdmlkZSB0aGUgd2lkdGggYnkgdGhlXG4gICAgYWxpZ25tZW50IGNsZWFubHlcbiAgICB2YWxpZCBhbGlnbm1lbnRzIGFyZSAxLDIsNCBhbmQgOFxuICAgIDQgaXMgdGhlIGRlZmF1bHRcblxuICAgICovXG4gICAgdmFyIGFsaWdubWVudHMgPSBbOCwgNCwgMiwgMV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGlnbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh3aWR0aCAlIGFsaWdubWVudHNbaV0gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldF90ZXh0dXJlX2RhdGEoYywgb2JqZWN0X2hhbmRsZSwgZ2xfdHlwZSwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBhcnJheSwgb2Zmc2V0LCBzaGFwZSwgZHR5cGUpIHtcbiAgICBjLmdsLmJpbmRUZXh0dXJlKGdsX3R5cGUsIG9iamVjdF9oYW5kbGUpO1xuXG4gICAgLy8gVE9ETzogY2hvb3NlIGEgYmV0dGVyIGFsaWdubWVudFxuICAgIGMuZ2wucGl4ZWxTdG9yZWkoYy5nbC5VTlBBQ0tfQUxJR05NRU5ULCAxKTtcblxuICAgIGlmIChhcnJheSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBzcGVjaWFsIHRleHR1cmUgYXR0YWNoZWQgdG8gZnJhbWUgYnVmZmVyIHRvIGJlIHJlbmRlcmVkIHRvXG4gICAgICAgIGMuZ2wudGV4SW1hZ2UyRChnbF90eXBlLCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgYy5nbC5VTlNJR05FRF9CWVRFLCBhcnJheSk7XG4gICAgfSBlbHNlIGlmIChhcnJheS5nZXRDb250ZXh0KSB7XG4gICAgICAgIC8vIEEgY2FudmFzIG9iamVjdFxuICAgICAgICBjLmdsLnRleEltYWdlMkQoZ2xfdHlwZSwgMCwgYy5nbC5SR0JBLCBjLmdsLlJHQkEsIGMuZ2wuVU5TSUdORURfQllURSwgYXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkuY2FudmFzKSB7XG4gICAgICAgIC8vIEEgY29udGV4dCBvYmplY3RcbiAgICAgICAgYy5nbC50ZXhJbWFnZTJEKGdsX3R5cGUsIDAsIGMuZ2wuUkdCQSwgYy5nbC5SR0JBLCBjLmdsLlVOU0lHTkVEX0JZVEUsIGFycmF5LmNhbnZhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFycmF5X3ZpZXc7XG4gICAgICAgIGlmIChkdHlwZSA9PSBjLmdsLkZMT0FUKSB7XG4gICAgICAgICAgICBhcnJheV92aWV3ID0gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheV92aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpc24ndCBpbml0aWFsaXppbmcgdGhlIHRleHR1cmUgKHRleEltYWdlMkQpIHRoZW4gc2VlIGlmIHdlXG4gICAgICAgIC8vIGNhbiBzZXQganVzdCBwYXJ0IG9mIHRoZSB0ZXh0dXJlXG4gICAgICAgIGlmIChvZmZzZXQgJiYgc2hhcGUgJiYgKChzaGFwZVswXSAhPT0gaGVpZ2h0KSB8fCAoc2hhcGVbMV0gIT09IHdpZHRoKSkpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdICogc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgYWxpZ25tZW50ID0gX2dldF9hbGlnbm1lbnQod2lkdGgpO1xuICAgICAgICAgICAgYy5nbC5waXhlbFN0b3JlaShjLmdsLlVOUEFDS19BTElHTk1FTlQsIGFsaWdubWVudCk7XG4gICAgICAgICAgICBjLmdsLnRleFN1YkltYWdlMkQoZ2xfdHlwZSwgMCwgb2Zmc2V0WzFdLCBvZmZzZXRbMF0sXG4gICAgICAgICAgICAgICAgc2hhcGVbMV0sIHNoYXBlWzBdLCBmb3JtYXQsIGR0eXBlLCBhcnJheV92aWV3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuZ2wucGl4ZWxTdG9yZWkoYy5nbC5VTlBBQ0tfQUxJR05NRU5ULCAxKTtcbiAgICAgICAgICAgIGMuZ2wudGV4SW1hZ2UyRChnbF90eXBlLCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsXG4gICAgICAgICAgICAgICAgZm9ybWF0LCBkdHlwZSwgYXJyYXlfdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldF9idWZmZXJfZGF0YShjLCBvYmplY3RfaGFuZGxlLCBnbF90eXBlLCBvZmZzZXQsIGFycmF5LCByZXVzZSkge1xuICAgIC8vIEJpbmQgdGhlIGJ1ZmZlciBiZWZvcmUgc2V0dGluZyB0aGUgZGF0YS5cbiAgICBjLmdsLmJpbmRCdWZmZXIoZ2xfdHlwZSwgb2JqZWN0X2hhbmRsZSk7XG5cbiAgICAvLyBVcGxvYWQgdGhlIGRhdGEuXG4gICAgaWYgKCFyZXVzZSkge1xuICAgICAgICAvLyBUaGUgZXhpc3RpbmcgYnVmZmVyIHdhcyBlbXB0eTogd2UgY3JlYXRlIGl0LlxuICAgICAgICBjLmdsLmJ1ZmZlckRhdGEoZ2xfdHlwZSwgYXJyYXksIGMuZ2wuU1RBVElDX0RSQVcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGJ1ZmZlci5cbiAgICAgICAgYy5nbC5idWZmZXJTdWJEYXRhKGdsX3R5cGUsIG9mZnNldCwgYXJyYXkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0X3VuaWZvcm0oYywgdW5pZm9ybV9oYW5kbGUsIHVuaWZvcm1fZnVuY3Rpb24sIHZhbHVlKSB7XG4gICAgLy8gR2V0IGEgVHlwZWRBcnJheS5cbiAgICBhcnJheSA9IHRvX2FycmF5X2J1ZmZlcih2YWx1ZSk7XG5cbiAgICBpZiAodW5pZm9ybV9mdW5jdGlvbi5pbmRleE9mKCdNYXRyaXgnKSA+IDApIHtcbiAgICAgICAgLy8gTWF0cml4IHVuaWZvcm1zLlxuICAgICAgICBjLmdsW3VuaWZvcm1fZnVuY3Rpb25dKHVuaWZvcm1faGFuZGxlLCBmYWxzZSwgYXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU2NhbGFyIHVuaWZvcm1zLlxuICAgICAgICBjLmdsW3VuaWZvcm1fZnVuY3Rpb25dKHVuaWZvcm1faGFuZGxlLCBhcnJheSk7XG4gICAgfVxufVxuXG52YXIgX2R0eXBlX3RvX2dsX2R0eXBlID0ge1xuICAgICdmbG9hdDMyJzogJ0ZMT0FUJyxcbiAgICAndWludDgnOiAnVU5TSUdORURfQllURScsXG59O1xuZnVuY3Rpb24gZ2V0X2dsX2R0eXBlKGR0eXBlKSB7XG4gICAgcmV0dXJuIF9kdHlwZV90b19nbF9kdHlwZVtkdHlwZV07XG59XG5cbnZhciBfYXR0cmlidXRlX3R5cGVfbWFwID0ge1xuICAgICdmbG9hdCc6IFsnRkxPQVQnLCAxXSxcbiAgICAndmVjMic6IFsnRkxPQVQnLCAyXSxcbiAgICAndmVjMyc6IFsnRkxPQVQnLCAzXSxcbiAgICAndmVjNCc6IFsnRkxPQVQnLCA0XSxcblxuICAgICdpbnQnOiBbJ0lOVCcsIDFdLFxuICAgICdpdmVjMic6IFsnSU5UJywgMl0sXG4gICAgJ2l2ZWMzJzogWydJTlQnLCAzXSxcbiAgICAnaXZlYzQnOiBbJ0lOVCcsIDRdLFxufTtcbmZ1bmN0aW9uIGdldF9hdHRyaWJ1dGVfaW5mbyh0eXBlKSB7XG4gICAgLy8gdHlwZTogdmVjMiwgaXZlYzMsIGZsb2F0LCBldGMuXG4gICAgcmV0dXJuIF9hdHRyaWJ1dGVfdHlwZV9tYXBbdHlwZV07XG59XG5cbnZhciBfdW5pZm9ybV90eXBlX21hcCA9IHtcbiAgICAnZmxvYXQnOiAndW5pZm9ybTFmdicsXG4gICAgJ3ZlYzInOiAndW5pZm9ybTJmdicsXG4gICAgJ3ZlYzMnOiAndW5pZm9ybTNmdicsXG4gICAgJ3ZlYzQnOiAndW5pZm9ybTRmdicsXG5cbiAgICAnaW50JzogJ3VuaWZvcm0xaXYnLFxuICAgICdpdmVjMic6ICd1bmlmb3JtMml2JyxcbiAgICAnaXZlYzMnOiAndW5pZm9ybTNpdicsXG4gICAgJ2l2ZWM0JzogJ3VuaWZvcm00aXYnLFxuXG4gICAgJ21hdDInOiAndW5pZm9ybU1hdHJpeDJmdicsXG4gICAgJ21hdDMnOiAndW5pZm9ybU1hdHJpeDNmdicsXG4gICAgJ21hdDQnOiAndW5pZm9ybU1hdHJpeDRmdicsXG59O1xuZnVuY3Rpb24gZ2V0X3VuaWZvcm1fZnVuY3Rpb24odHlwZSkge1xuICAgIC8vIEZpbmQgT3BlbkdMIHVuaWZvcm0gZnVuY3Rpb24uXG4gICAgcmV0dXJuIF91bmlmb3JtX3R5cGVfbWFwW3R5cGVdO1xufVxuXG52YXIgX2dsX3R5cGVfbWFwID0ge1xuICAgIFZlcnRleEJ1ZmZlcjogJ0FSUkFZX0JVRkZFUicsXG4gICAgSW5kZXhCdWZmZXI6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUicsXG4gICAgVGV4dHVyZTJEOiAnVEVYVFVSRV8yRCcsXG59O1xuXG5mdW5jdGlvbiBnZXRfZ2xfdHlwZShvYmplY3RfdHlwZSkge1xuICAgIHJldHVybiBfZ2xfdHlwZV9tYXBbb2JqZWN0X3R5cGVdO1xufVxuXG52YXIgX2dsX2F0dGFjaG1lbnRfbWFwID0ge1xuICAgICdjb2xvcic6IFsnQ09MT1JfQVRUQUNITUVOVDAnLCAnUkdCQTQnXSxcbiAgICAnZGVwdGgnOiBbJ0RFUFRIX0FUVEFDSE1FTlQnLCAnREVQVEhfQ09NUE9ORU5UMTYnXSxcbiAgICAnc3RlbmNpbCc6IFsnU1RFTkNJTF9BVFRBQ0hNRU5UJywgJ1NURU5DSUxfSU5ERVg4J10sXG59O1xuXG5mdW5jdGlvbiBnZXRfYXR0YWNobWVudF90eXBlKHR5cGVfc3RyKSB7XG4gICAgcmV0dXJuIF9nbF9hdHRhY2htZW50X21hcFt0eXBlX3N0cl1bMF07XG59XG5cbmZ1bmN0aW9uIGdldF9hdHRhY2htZW50X2Zvcm1hdCh0eXBlX3N0cikge1xuICAgIHJldHVybiBfZ2xfYXR0YWNobWVudF9tYXBbdHlwZV9zdHJdWzFdO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9lbnVtKGMsIHN0cikge1xuICAgIC8vIFBhcnNlIGFuIGVudW0gb3IgY29tYmluYXRpb24gb2YgZW51bXMgc3RvcmVkIGluIGEgc3RyaW5nLlxuICAgIHZhciBzdHJzID0gc3RyLnNwbGl0KCd8Jyk7XG4gICAgdmFyIHZhbHVlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzdHJzW2ldLnRvVXBwZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHwgYy5nbFtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZV9mcmFtZWJ1ZmZlcihjKSB7XG4gICAgdmFyIHN0YXR1cyA9IGMuZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhjLmdsLkZSQU1FQlVGRkVSKTtcbiAgICBpZiAoc3RhdHVzID09IGMuZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRk9STUFUUzogLy8gbm90IGluIGVzIDIuMFxuICAgIC8vICAgICAnSW50ZXJuYWwgZm9ybWF0IG9mIGF0dGFjaG1lbnQgaXMgbm90IHJlbmRlcmFibGUuJ1xuICAgIGlmIChzdGF0dXMgPT0gYy5nbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQpIHtcbiAgICAgICAgdGhyb3cgJ0ZyYW1lQnVmZmVyIGF0dGFjaG1lbnRzIGFyZSBpbmNvbXBsZXRlLic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXR1cyA9PSBjLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UKSB7XG4gICAgICAgIHRocm93ICdObyB2YWxpZCBhdHRhY2htZW50cyBpbiB0aGUgRnJhbWVCdWZmZXIuJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdHVzID09IGMuZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TKSB7XG4gICAgICAgIHRocm93ICdhdHRhY2htZW50cyBkbyBub3QgaGF2ZSB0aGUgc2FtZSB3aWR0aCBhbmQgaGVpZ2h0Lic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXR1cyA9PSBjLmdsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEKSB7XG4gICAgICAgIHRocm93ICdDb21iaW5hdGlvbiBvZiBpbnRlcm5hbCBmb3JtYXRzIHVzZWQgYnkgYXR0YWNobWVudHMgaXMgbm90IHN1cHBvcnRlZC4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgJ1Vua25vd24gZnJhbWVidWZmZXIgZXJyb3InICsgc3RhdHVzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVfZnJhbWVidWZmZXIoYywgZnJhbWVidWZmZXJfaWQpIHtcbiAgICB2YXIgZmIgPSBjLl9uc1tmcmFtZWJ1ZmZlcl9pZF07XG4gICAgdmFyIHN0YWNrID0gYy5lbnYuZmJfc3RhY2s7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBmYi5oYW5kbGUpIHtcbiAgICAgICAgZGVidWcoXCJGcmFtZSBidWZmZXIgYWxyZWFkeSBhY3RpdmUgezB9XCIuZm9ybWF0KGZyYW1lYnVmZmVyX2lkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVidWcoXCJCaW5kaW5nIGZyYW1lIGJ1ZmZlciB7MH0uXCIuZm9ybWF0KGZyYW1lYnVmZmVyX2lkKSk7XG4gICAgYy5nbC5iaW5kRnJhbWVidWZmZXIoYy5nbC5GUkFNRUJVRkZFUiwgZmIuaGFuZGxlKTtcbiAgICBzdGFjay5wdXNoKGZiLmhhbmRsZSk7XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVfZnJhbWVidWZmZXIoYywgZnJhbWVidWZmZXJfaWQpIHtcbiAgICB2YXIgZmIgPSBjLl9uc1tmcmFtZWJ1ZmZlcl9pZF07XG4gICAgdmFyIHN0YWNrID0gYy5lbnYuZmJfc3RhY2s7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobnVsbCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBmYi5oYW5kbGUpIHtcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSBjdXJyZW50IGZyYW1lIGJ1ZmZlclxuICAgICAgICBzdGFjay5wb3AoKTsgLy8gJ3VuYmluZCcgY3VycmVudCBidWZmZXJcbiAgICB9XG4gICAgLy8gQWN0aXZhdGUgcHJldmlvdXMgZnJhbWUgYnVmZmVyXG4gICAgLy8gTk9URTogb3V0IG9mIGJvdW5kcyBpbmRleCBpZiB0cnlpbmcgdG8gdW5iaW5kIHRoZSBkZWZhdWx0IChudWxsKSBmcmFtZWJ1ZmZlclxuICAgIGRlYnVnKFwiQmluZGluZyBwcmV2aW91cyBmcmFtZSBidWZmZXJcIik7XG4gICAgYy5nbC5iaW5kRnJhbWVidWZmZXIoYy5nbC5GUkFNRUJVRkZFUiwgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBpbml0X2Vudl9jYWNoZShjKSB7XG4gICAgYy5lbnYgPSB7XG4gICAgICAgICdmYl9zdGFjayc6IFtdLFxuICAgIH07XG59XG5cblxuLyogR2xpciBxdWV1ZSBwcm90b3R5cGUgKi9cbmZ1bmN0aW9uIEdsaXJRdWV1ZSgpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xufVxuR2xpclF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG59O1xuR2xpclF1ZXVlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChlKTtcbn07XG5HbGlyUXVldWUucHJvdG90eXBlLmFwcGVuZF9tdWx0aSA9IGZ1bmN0aW9uKGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGVzW2ldKTtcbiAgICB9XG59O1xuR2xpclF1ZXVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWU7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdsaXJRdWV1ZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fcXVldWUubGVuZ3RoOyB9LFxufSk7XG5cblxuLyogVmlzcHkgY2FudmFzIEdMSVIgbWV0aG9kcyAqL1xuVmlzcHlDYW52YXMucHJvdG90eXBlLnNldF9kZWZlcnJlZCA9IGZ1bmN0aW9uKGRlZmVycmVkKSB7XG4gICAgdGhpcy5fZGVmZXJyZWQgPSBkZWZlcnJlZDtcbn07XG5cblZpc3B5Q2FudmFzLnByb3RvdHlwZS5leGVjdXRlX3BlbmRpbmdfY29tbWFuZHMgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBSZXR1cm4gdGhlIG51bWJlciBvZiBleGVjdXRlZCBHTElSIGNvbW1hbmRzLiAqL1xuICAgIHZhciBxID0gdGhpcy5nbGlyX3F1ZXVlLmdldCgpO1xuICAgIHZhciBleGVjdXRlX3VwX3RvID0gLTE7XG4gICAgaWYgKHEubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gT25seSBzdGFydCBleGVjdXRpbmcgaWYgd2Ugc2VlIGEgU1dBUCBjb21tYW5kXG4gICAgLy8gQW55ICdkcmF3JyBjb21tYW5kIChjbGVhciwgZHJhdywgZXRjKSB3aWxsIGNhdXNlIHRoZSBicm93c2VyIHRvXG4gICAgLy8gc3dhcCB0aGUgd2ViZ2wgZHJhd2luZyBidWZmZXJzLiBJZiB3ZSBzdGFydCBleGVjdXRpbmcgZHJhdyBjb21tYW5kc1xuICAgIC8vIGJlZm9yZSB3ZSBhcmUgcmVhZHkgZm9yIHRoZSBidWZmZXJzIHRvIHN3YXAgd2UgY291bGQgZ2V0IGFuIGluY29tcGxldGVcbiAgICAvLyBjYW52YXMgKG9ubHkgJ2NsZWFyJyBiZWluZyBjb21wbGV0ZWQsIGxlc3MgdGhhbiBhbGwgb2YgdGhlXG4gICAgLy8gZXhwZWN0ZWQgb2JqZWN0cyBiZWluZyBkcmF3biwgZXRjKS5cbiAgICAvLyBUaGlzIHRlY2huaWNhbGx5IG9ubHkgaGFwcGVucyBpZiBub3QgYWxsIHRoZSBHTElSIGNvbW1hbmRzIHdlcmVcbiAgICAvLyByZWNlaXZlZCBieSB0aGUgdGltZSB0aGlzIGFuaW1hdGlvbiBsb29wIHN0YXJ0ZWQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChxW2ldWzBdID09PSAnU1dBUCcpIHtcbiAgICAgICAgICAgIGV4ZWN1dGVfdXBfdG8gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhlY3V0ZSBhbGwgY29tbWFuZHMgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgU1dBUFxuICAgIGZvciAoaSA9IDA7IGkgPD0gZXhlY3V0ZV91cF90bzsgaSsrKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZChxW2ldLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGV4ZWN1dGVfdXBfdG8gPj0gMCkge1xuICAgICAgICBkZWJ1ZyhcIlByb2Nlc3NlZCB7MH0gZXZlbnRzLlwiLmZvcm1hdChleGVjdXRlX3VwX3RvICsgMSkpO1xuICAgICAgICAvLyB0aGlzLmdsaXJfcXVldWUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5nbGlyX3F1ZXVlLl9xdWV1ZSA9IHRoaXMuZ2xpcl9xdWV1ZS5fcXVldWUuc2xpY2UoZXhlY3V0ZV91cF90byArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZXhlY3V0ZV91cF90byArIDE7XG59O1xuXG5WaXNweUNhbnZhcy5wcm90b3R5cGUuY29tbWFuZCA9IGZ1bmN0aW9uKGNvbW1hbmQsIGRlZmVycmVkKSB7XG4gICAgaWYgKGRlZmVycmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmZXJyZWQgPSB0aGlzLl9kZWZlcnJlZDtcbiAgICB9XG4gICAgdmFyIG1ldGhvZCA9IGNvbW1hbmRbMF0udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5nbGlyX3F1ZXVlLmFwcGVuZChjb21tYW5kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZ2xpclttZXRob2RdKHRoaXMsIGNvbW1hbmQuc2xpY2UoMSkpO1xuICAgIH1cbn07XG5cblxuLyogQ3JlYXRpb24gb2YgdmlzcHkuZ2xvby5nbGlyICovXG52YXIgZ2xpciA9IGZ1bmN0aW9uKCkgeyB9O1xuXG5nbGlyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYykge1xuICAgIC8vIE5hbWVzcGFjZSB3aXRoIHRoZSB0YWJsZSBvZiBhbGwgc3ltYm9scyB1c2VkIGJ5IEdMSVIuXG5cbiAgICAvLyBUaGUga2V5IGlzIHVzZXItc3BlY2lmaWVkIGFuZCBpcyBuYW1lZCB0aGUgKippZCoqLlxuICAgIC8vIFRoZSBXZWJHTCBpbnRlcm5hbCBoYW5kbGUgaXMgY2FsbGVkIHRoZSAqKmhhbmRsZSoqLlxuXG4gICAgLy8gRm9yIGVhY2ggaWQga2V5LCB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgIC8vICogb2JqZWN0X3R5cGUgKCdWZXJ0ZXhCdWZmZXInLCAnUHJvZ3JhbScsIGV0Yy4pXG4gICAgLy8gKiBoYW5kbGUgKHRoZSBXZWJHTCBpbnRlcm5hbCBoYW5kbGUsIGZvciBhbGwgb2JqZWN0cylcbiAgICAvLyAqIGRhdGFfdHlwZSAoZm9yIEJ1ZmZlcnMpXG4gICAgLy8gKiBvZmZzZXQgKGZvciBCdWZmZXJzKVxuICAgIC8vICogYXR0cmlidXRlcyAoZm9yIFByb2dyYW1zKVxuICAgIC8vICogdW5pZm9ybXMgKGZvciBQcm9ncmFtcylcbiAgICBjLl9ucyA9IHt9O1xuICAgIC8vIERlZmVycmVkIG1vZGUgaXMgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgIGMuX2RlZmVycmVkID0gdHJ1ZTtcbiAgICAvLyBQZXItY29udGV4dCBzdG9yYWdlIGZvciBHTElSIG9iamVjdHMgKGZyYW1lYnVmZmVyIHN0YWNrLCBldGMpXG4gICAgaW5pdF9lbnZfY2FjaGUoYyk7XG4gICAgYy5nbGlyX3F1ZXVlID0gbmV3IEdsaXJRdWV1ZSgpO1xuICAgIGMuZ2xpciA9IHRoaXM7XG59O1xuXG5nbGlyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24oYywgYXJncykge1xuICAgIGluaXRfZW52X2NhY2hlKGMpO1xuICAgIGMuZ2wuYmluZEZyYW1lYnVmZmVyKGMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxuZ2xpci5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKGMsIGFyZ3MpIHtcblxufTtcblxuZ2xpci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oYywgYXJncykge1xuICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgdmFyIGNscyA9IGFyZ3NbMV07XG4gICAgaWYgKGNscyA9PSAnVmVydGV4QnVmZmVyJykge1xuICAgICAgICBkZWJ1ZyhcIkNyZWF0aW5nIHZlcnRleCBidWZmZXIgJ3swfScuXCIuZm9ybWF0KGlkKSk7XG4gICAgICAgIGMuX25zW2lkXSA9IHtcbiAgICAgICAgICAgIG9iamVjdF90eXBlOiBjbHMsXG4gICAgICAgICAgICBoYW5kbGU6IGMuZ2wuY3JlYXRlQnVmZmVyKCksXG4gICAgICAgICAgICBzaXplOiAwLCAgLy8gY3VycmVudCBzaXplIG9mIHRoZSBidWZmZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xzID09ICdJbmRleEJ1ZmZlcicpIHtcbiAgICAgICAgZGVidWcoXCJDcmVhdGluZyBpbmRleCBidWZmZXIgJ3swfScuXCIuZm9ybWF0KGlkKSk7XG4gICAgICAgIGMuX25zW2lkXSA9IHtcbiAgICAgICAgICAgIG9iamVjdF90eXBlOiBjbHMsXG4gICAgICAgICAgICBoYW5kbGU6IGMuZ2wuY3JlYXRlQnVmZmVyKCksXG4gICAgICAgICAgICBzaXplOiAwLCAgLy8gY3VycmVudCBzaXplIG9mIHRoZSBidWZmZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xzID09ICdGcmFtZUJ1ZmZlcicpIHtcbiAgICAgICAgZGVidWcoXCJDcmVhdGluZyBmcmFtZSBidWZmZXIgJ3swfScuXCIuZm9ybWF0KGlkKSk7XG4gICAgICAgIGMuX25zW2lkXSA9IHtcbiAgICAgICAgICAgIG9iamVjdF90eXBlOiBjbHMsXG4gICAgICAgICAgICBoYW5kbGU6IGMuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSxcbiAgICAgICAgICAgIHNpemU6IDAsICAvLyBjdXJyZW50IHNpemUgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgdmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xzID09ICdSZW5kZXJCdWZmZXInKSB7XG4gICAgICAgIGRlYnVnKFwiQ3JlYXRpbmcgcmVuZGVyIGJ1ZmZlciAnezB9Jy5cIi5mb3JtYXQoaWQpKTtcbiAgICAgICAgYy5fbnNbaWRdID0ge1xuICAgICAgICAgICAgb2JqZWN0X3R5cGU6IGNscyxcbiAgICAgICAgICAgIGhhbmRsZTogYy5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKSxcbiAgICAgICAgICAgIHNpemU6IDAsICAvLyBjdXJyZW50IHNpemUgb2YgdGhlIGJ1ZmZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjbHMgPT0gJ1RleHR1cmUyRCcpIHtcbiAgICAgICAgZGVidWcoXCJDcmVhdGluZyB0ZXh0dXJlICd7MH0nLlwiLmZvcm1hdChpZCkpO1xuICAgICAgICBjLl9uc1tpZF0gPSB7XG4gICAgICAgICAgICBvYmplY3RfdHlwZTogY2xzLFxuICAgICAgICAgICAgaGFuZGxlOiBjLmdsLmNyZWF0ZVRleHR1cmUoKSxcbiAgICAgICAgICAgIHNpemU6IDAsICAvLyBjdXJyZW50IHNpemUgb2YgdGhlIHRleHR1cmVcbiAgICAgICAgICAgIHNoYXBlOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xzID09ICdQcm9ncmFtJykge1xuICAgICAgICBkZWJ1ZyhcIkNyZWF0aW5nIHByb2dyYW0gJ3swfScuXCIuZm9ybWF0KGlkKSk7XG4gICAgICAgIGMuX25zW2lkXSA9IHtcbiAgICAgICAgICAgIG9iamVjdF90eXBlOiBjbHMsXG4gICAgICAgICAgICBoYW5kbGU6IGMuZ2wuY3JlYXRlUHJvZ3JhbSgpLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgICB1bmlmb3Jtczoge30sXG4gICAgICAgICAgICB0ZXh0dXJlczoge30sIC8vIG1hcCB0ZXh0dXJlX2lkIC0+IHNhbXBsZXJfbmFtZSwgc2FtcGxlcl9oYW5kbGUsIG51bWJlciwgaGFuZGxlXG4gICAgICAgICAgICB0ZXh0dXJlX3VuaWZvcm1zOiB7fSwgLy8gbWFwIHNhbXBsZXJfbmFtZSAtPiB0ZXh0dXJlX2lkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNscyA9PSAnVmVydGV4U2hhZGVyJykge1xuICAgICAgICBkZWJ1ZyhcIkNyZWF0aW5nIFZlcnRleFNoYWRlciAnezB9Jy5cIi5mb3JtYXQoaWQpKTtcbiAgICAgICAgYy5fbnNbaWRdID0ge1xuICAgICAgICAgICAgb2JqZWN0X3R5cGU6IGNscyxcbiAgICAgICAgICAgIGhhbmRsZTogYy5nbC5jcmVhdGVTaGFkZXIoYy5nbFsnVkVSVEVYX1NIQURFUiddKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xzID09ICdGcmFnbWVudFNoYWRlcicpIHtcbiAgICAgICAgZGVidWcoXCJDcmVhdGluZyBGcmFnbWVudFNoYWRlciAnezB9Jy5cIi5mb3JtYXQoaWQpKTtcbiAgICAgICAgYy5fbnNbaWRdID0ge1xuICAgICAgICAgICAgb2JqZWN0X3R5cGU6IGNscyxcbiAgICAgICAgICAgIGhhbmRsZTogYy5nbC5jcmVhdGVTaGFkZXIoYy5nbFsnRlJBR01FTlRfU0hBREVSJ10pLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmdsaXIucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKGMsIGFyZ3MpIHtcbiAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgIHZhciBjbHMgPSBjLl9uc1tpZF0ub2JqZWN0X3R5cGU7XG4gICAgdmFyIGhhbmRsZSA9IGMuX25zW2lkXS5oYW5kbGU7XG4gICAgYy5fbnNbaWRdLmhhbmRsZSA9IEpVU1RfREVMRVRFRDtcbiAgICBpZiAoY2xzID09ICdWZXJ0ZXhCdWZmZXInKSB7XG4gICAgICAgIGRlYnVnKFwiRGVsZXRpbmcgdmVydGV4IGJ1ZmZlciAnezB9Jy5cIi5mb3JtYXQoaWQpKTtcbiAgICAgICAgYy5nbC5kZWxldGVCdWZmZXIoaGFuZGxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xzID09ICdJbmRleEJ1ZmZlcicpIHtcbiAgICAgICAgZGVidWcoXCJEZWxldGluZyBpbmRleCBidWZmZXIgJ3swfScuXCIuZm9ybWF0KGlkKSk7XG4gICAgICAgIGMuZ2wuZGVsZXRlQnVmZmVyKGhhbmRsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNscyA9PSAnRnJhbWVCdWZmZXInKSB7XG4gICAgICAgIGRlYnVnKFwiRGVsZXRpbmcgZnJhbWUgYnVmZmVyICd7MH0nLlwiLmZvcm1hdChpZCkpO1xuICAgICAgICBjLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKGhhbmRsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNscyA9PSAnUmVuZGVyQnVmZmVyJykge1xuICAgICAgICBkZWJ1ZyhcIkRlbGV0aW5nIHJlbmRlciBidWZmZXIgJ3swfScuXCIuZm9ybWF0KGlkKSk7XG4gICAgICAgIGMuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGhhbmRsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNscyA9PSAnVGV4dHVyZTJEJykge1xuICAgICAgICBkZWJ1ZyhcIkRlbGV0aW5nIHRleHR1cmUgJ3swfScuXCIuZm9ybWF0KGlkKSk7XG4gICAgICAgIGMuZ2wuZGVsZXRlVGV4dHVyZShoYW5kbGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbHMgPT0gJ1Byb2dyYW0nKSB7XG4gICAgICAgIGRlYnVnKFwiRGVsZXRpbmcgcHJvZ3JhbSAnezB9Jy5cIi5mb3JtYXQoaWQpKTtcbiAgICAgICAgYy5nbC5kZWxldGVQcm9ncmFtKGhhbmRsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNscy5pbmRleE9mKCdTaGFkZXInKSA+PSAwKSB7XG4gICAgICAgIGRlYnVnKFwiRGVsZXRpbmcgc2hhZGVyICd7MH0nLlwiLmZvcm1hdChpZCkpO1xuICAgICAgICBjLmdsLmRlbGV0ZVNoYWRlcihoYW5kbGUpO1xuICAgIH1cbn07XG5cbmdsaXIucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbihjLCBhcmdzKSB7XG4gICAgdmFyIG9iamVjdF9pZCA9IGFyZ3NbMF07XG4gICAgdmFyIHNpemUgPSBhcmdzWzFdOyAgLy8gV0FSTklORzogc2l6ZSBtdXN0IGJlIGluIGJ5dGVzIVxuICAgIHZhciBmb3JtYXQgPSBhcmdzWzJdO1xuICAgIHZhciBvYmplY3QgPSBjLl9uc1tvYmplY3RfaWRdO1xuICAgIHZhciBvYmplY3RfaGFuZGxlID0gb2JqZWN0LmhhbmRsZTtcbiAgICB2YXIgb2JqZWN0X3R5cGUgPSBvYmplY3Qub2JqZWN0X3R5cGU7XG4gICAgdmFyIGdsX3R5cGUgPSBjLmdsW2dldF9nbF90eXBlKG9iamVjdF90eXBlKV07XG5cbiAgICAvLyBUZXh0dXJlcy5cbiAgICBpZiAob2JqZWN0X3R5cGUuaW5kZXhPZignVGV4dHVyZScpID49IDApIHtcbiAgICAgICAgLy8gZm9ybWF0IGlzICdMVU1JTkFOQ0UnLCAnQUxQSEEnLCAnTFVNSU5BTkNFX0FMUEhBJywgJ1JHQicgb3IgJ1JHQkEnXG4gICAgICAgIG9iamVjdC5mb3JtYXQgPSBmb3JtYXQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgZGVidWcoXCJTZXR0aW5nIHRleHR1cmUgc2l6ZSB0byB7MX0gZm9yICd7MH0nLlwiLmZvcm1hdChvYmplY3RfaWQsIHNpemUpKTtcbiAgICAgICAgLy8gSEFDSzogaXQgZG9lc24ndCBzZWVtIHdlIGNhbiBjaGFuZ2UgdGhlIHRleHR1cmUgc2l6ZSB3aXRob3V0XG4gICAgICAgIC8vIGFsbG9jYXRpbmcgYSBidWZmZXIgaW4gV2ViR0wsIHNvIHdlIGp1c3Qgc3RvcmUgdGhlIHNpemUgYW5kXG4gICAgICAgIC8vIGZvcm1hdCBpbiB0aGUgb2JqZWN0LCBhbmQgd2UnbGwgdXNlIHRoaXMgaW5mb3JtYXRpb24gaW4gdGhlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgREFUQSBjYWxsLlxuICAgIH1cbiAgICBlbHNlIGlmIChvYmplY3RfdHlwZSA9PSAnUmVuZGVyQnVmZmVyJykge1xuICAgICAgICBjLmdsLmJpbmRSZW5kZXJidWZmZXIoYy5nbC5SRU5ERVJCVUZGRVIsIG9iamVjdF9oYW5kbGUpO1xuICAgICAgICBvYmplY3QuZm9ybWF0ID0gYy5nbFtnZXRfYXR0YWNobWVudF9mb3JtYXQoZm9ybWF0KV07XG4gICAgICAgIC8vIHNpemUgaXMgWSwgWCwgWlxuICAgICAgICAvLyBhc3N1bWUgWSBpcyByb3dzIChoZWlnaHQpLCBYIGlzIGNvbHVtbnMgKHdpZHRoKVxuICAgICAgICAvLyBhc3N1bWUgWiBpcyBjb2xvciBpbmZvcm1hdGlvbiAoaWdub3JlZClcbiAgICAgICAgYy5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKGMuZ2wuUkVOREVSQlVGRkVSLCBvYmplY3QuZm9ybWF0LCBzaXplWzFdLCBzaXplWzBdKTtcbiAgICAgICAgYy5nbC5iaW5kUmVuZGVyYnVmZmVyKGMuZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICB9XG4gICAgLy8gQnVmZmVyc1xuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGRlYnVnKFwiU2V0dGluZyBidWZmZXIgc2l6ZSB0byB7MX0gZm9yICd7MH0nLlwiLmZvcm1hdChvYmplY3RfaWQsIHNpemUpKTtcbiAgICAgICAgLy8gUmV1c2UgdGhlIGJ1ZmZlciBpZiB0aGUgZXhpc3Rpbmcgc2l6ZSBpcyBub3QgbnVsbC5cbiAgICAgICAgc2V0X2J1ZmZlcl9kYXRhKGMsIG9iamVjdF9oYW5kbGUsIGdsX3R5cGUsIDAsIHNpemUsIGZhbHNlKTtcbiAgICB9XG4gICAgLy8gU2F2ZSB0aGUgc2l6ZS5cbiAgICBvYmplY3Quc2l6ZSA9IHNpemU7XG59O1xuXG5nbGlyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oYywgYXJncykge1xuICAgIHZhciBvYmplY3RfaWQgPSBhcmdzWzBdO1xuICAgIHZhciBvZmZzZXQgPSBhcmdzWzFdO1xuICAgIHZhciBkYXRhID0gYXJnc1syXTtcbiAgICB2YXIgb2JqZWN0ID0gYy5fbnNbb2JqZWN0X2lkXTtcbiAgICB2YXIgb2JqZWN0X3R5cGUgPSBvYmplY3Qub2JqZWN0X3R5cGU7IC8vIFZlcnRleEJ1ZmZlciwgSW5kZXhCdWZmZXIsIG9yIFRleHR1cmUyRFxuICAgIHZhciBvYmplY3RfaGFuZGxlID0gb2JqZWN0LmhhbmRsZTtcbiAgICB2YXIgZ2xfdHlwZSA9IGMuZ2xbZ2V0X2dsX3R5cGUob2JqZWN0X3R5cGUpXTtcbiAgICAvLyBHZXQgYSBUeXBlZEFycmF5LlxuICAgIHZhciBhcnJheSA9IHRvX2FycmF5X2J1ZmZlcihkYXRhKTtcblxuICAgIGlmIChvYmplY3RfdHlwZS5pbmRleE9mKCdTaGFkZXInKSA+PSAwKSB7XG4gICAgICAgIC8vIENvbXBpbGUgc2hhZGVyIGNvZGUgdG8gc2hhZGVyIG9iamVjdFxuICAgICAgICBjb21waWxlX3NoYWRlcihjLCBvYmplY3RfaGFuZGxlLCBhcnJheSk7XG4gICAgfVxuICAgIC8vIFRleHR1cmVzLlxuICAgIGVsc2UgaWYgKG9iamVjdF90eXBlLmluZGV4T2YoJ1RleHR1cmUnKSA+PSAwKSB7XG4gICAgICAgIC8vIFRoZSB0ZXh0dXJlIHNoYXBlIHdhcyBzcGVjaWZpZWQgaW4gU0laRVxuICAgICAgICB2YXIgc2hhcGUgPSBvYmplY3Quc2l6ZTtcbiAgICAgICAgLy8gV0FSTklORzogdGhpcyBpcyBoZWlnaHQgYW5kIHRoZW4gd2lkdGgsIG5vdCB0aGUgb3RoZXIgd2F5XG4gICAgICAgIC8vIGFyb3VuZC5cbiAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlWzBdO1xuICAgICAgICB2YXIgd2lkdGggPSBzaGFwZVsxXTtcblxuICAgICAgICAvLyBUaGUgdGV4dHVyZSBmb3JtYXQgd2FzIHNwZWNpZmllZCBpbiBTSVpFLlxuICAgICAgICB2YXIgZm9ybWF0ID0gYy5nbFtvYmplY3QuZm9ybWF0XTtcblxuICAgICAgICBkZWJ1ZyhcIlNldHRpbmcgdGV4dHVyZSBkYXRhIGZvciAnezB9Jy5cIi5mb3JtYXQob2JqZWN0X2lkKSk7XG4gICAgICAgIC8vIGBkYXRhLnNoYXBlYCBjb21lcyBmcm9tIG5vdGVib29rIGJhY2tlbmQgYW5kIHZpc3B5IHdlYmdsIGV4dGVuc2lvblxuICAgICAgICAvLyB3aXRob3V0IGl0LCBzdWJpbWFnZSB0ZXh0dXJlIHdyaXRlcyBkbyBub3Qgd29ya1xuICAgICAgICB2YXIgZ2xfZHR5cGUgPSBjLmdsW2dldF9nbF9kdHlwZShkYXRhLmR0eXBlKV07XG4gICAgICAgIHNldF90ZXh0dXJlX2RhdGEoYywgb2JqZWN0X2hhbmRsZSwgZ2xfdHlwZSwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBhcnJheSwgb2Zmc2V0LCBkYXRhLnNoYXBlLCBnbF9kdHlwZSk7XG4gICAgICAgIG9iamVjdC5zaGFwZSA9IHNoYXBlO1xuICAgIH1cbiAgICAvLyBCdWZmZXJzXG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZGVidWcoXCJTZXR0aW5nIGJ1ZmZlciBkYXRhIGZvciAnezB9Jy5cIi5mb3JtYXQob2JqZWN0X2lkKSk7XG4gICAgICAgIC8vIFJldXNlIHRoZSBidWZmZXIgaWYgdGhlIGV4aXN0aW5nIHNpemUgaXMgbm90IG51bGwuXG4gICAgICAgIHNldF9idWZmZXJfZGF0YShjLCBvYmplY3RfaGFuZGxlLCBnbF90eXBlLCBvZmZzZXQsIGFycmF5LCBvYmplY3Quc2l6ZSA+IDApO1xuICAgICAgICBvYmplY3Quc2l6ZSA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgfVxufTtcblxuZ2xpci5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24oYywgYXJncykge1xuICAgIHZhciBwcm9ncmFtX2lkID0gYXJnc1swXTtcbiAgICB2YXIgbmFtZSA9IGFyZ3NbMV07XG4gICAgdmFyIHR5cGUgPSBhcmdzWzJdO1xuICAgIC8vIFRPRE86IHN1cHBvcnQgbm9uLVZCTyBkYXRhXG4gICAgdmFyIHZib19pZCA9IGFyZ3NbM11bMF07XG4gICAgdmFyIHN0cmlkZSA9IGFyZ3NbM11bMV07XG4gICAgdmFyIG9mZnNldCA9IGFyZ3NbM11bMl07XG5cbiAgICB2YXIgcHJvZ3JhbV9oYW5kbGUgPSBjLl9uc1twcm9ncmFtX2lkXS5oYW5kbGU7XG5cbiAgICBkZWJ1ZyhcIkNyZWF0aW5nIGF0dHJpYnV0ZSAnezB9JyBmb3IgcHJvZ3JhbSAnezF9Jy5cIi5mb3JtYXQoXG4gICAgICAgICAgICBuYW1lLCBwcm9ncmFtX2lkXG4gICAgICAgICkpO1xuICAgIHZhciBhdHRyaWJ1dGVfaGFuZGxlID0gY3JlYXRlX2F0dHJpYnV0ZShjLCBwcm9ncmFtX2hhbmRsZSwgbmFtZSk7XG5cbiAgICAvLyBTdG9yZSB0aGUgYXR0cmlidXRlIGhhbmRsZSBpbiB0aGUgYXR0cmlidXRlcyBhcnJheSBvZiB0aGUgcHJvZ3JhbS5cbiAgICBjLl9uc1twcm9ncmFtX2lkXS5hdHRyaWJ1dGVzW25hbWVdID0ge1xuICAgICAgICBoYW5kbGU6IGF0dHJpYnV0ZV9oYW5kbGUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZib19pZDogdmJvX2lkLFxuICAgICAgICBzdHJpZGU6IHN0cmlkZSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgfTtcbn07XG5cbmdsaXIucHJvdG90eXBlLnVuaWZvcm0gPSBmdW5jdGlvbihjLCBhcmdzKSB7XG4gICAgdmFyIHByb2dyYW1faWQgPSBhcmdzWzBdO1xuICAgIHZhciBuYW1lID0gYXJnc1sxXTtcbiAgICB2YXIgdHlwZSA9IGFyZ3NbMl07XG4gICAgdmFyIHZhbHVlID0gYXJnc1szXTtcblxuICAgIHZhciBwcm9ncmFtX2hhbmRsZSA9IGMuX25zW3Byb2dyYW1faWRdLmhhbmRsZTtcblxuICAgIGMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtX2hhbmRsZSk7XG5cbiAgICAvLyBDaGVjayB0aGUgY2FjaGUuXG4gICAgaWYgKGMuX25zW3Byb2dyYW1faWRdLnVuaWZvcm1zW25hbWVdID09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiBuZWNlc3NhcnksIHdlIGNyZWF0ZSB0aGUgdW5pZm9ybSBhbmQgY2FjaGUgYm90aCBpdHMgaGFuZGxlIGFuZFxuICAgICAgICAvLyBHTCBmdW5jdGlvbi5cbiAgICAgICAgZGVidWcoXCJDcmVhdGluZyB1bmlmb3JtICd7MH0nIGZvciBwcm9ncmFtICd7MX0nLlwiLmZvcm1hdChcbiAgICAgICAgICAgICAgICBuYW1lLCBwcm9ncmFtX2lkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgdmFyIHVuaWZvcm1faGFuZGxlID0gYy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbV9oYW5kbGUsIG5hbWUpO1xuICAgICAgICB2YXIgdW5pZm9ybV9mdW5jdGlvbiA9IGdldF91bmlmb3JtX2Z1bmN0aW9uKHR5cGUpO1xuICAgICAgICAvLyBXZSBjYWNoZSB0aGUgdW5pZm9ybSBoYW5kbGUgYW5kIHRoZSB1bmlmb3JtIGZ1bmN0aW9uIG5hbWUgYXMgd2VsbC5cbiAgICAgICAgYy5fbnNbcHJvZ3JhbV9pZF0udW5pZm9ybXNbbmFtZV0gPSBbdW5pZm9ybV9oYW5kbGUsIHVuaWZvcm1fZnVuY3Rpb25dO1xuICAgIH1cblxuICAgIGRlYnVnKFwiU2V0dGluZyB1bmlmb3JtICd7MH0nIHRvICd7MX0nIHdpdGggezJ9IGVsZW1lbnRzLlwiLmZvcm1hdChcbiAgICAgICAgICAgIG5hbWUsIHZhbHVlLCB2YWx1ZS5sZW5ndGhcbiAgICAgICAgKSk7XG4gICAgdmFyIHVuaWZvcm1faW5mbyA9IGMuX25zW3Byb2dyYW1faWRdLnVuaWZvcm1zW25hbWVdO1xuICAgIHZhciB1bmlmb3JtX2hhbmRsZSA9IHVuaWZvcm1faW5mb1swXTtcbiAgICB2YXIgdW5pZm9ybV9mdW5jdGlvbiA9IHVuaWZvcm1faW5mb1sxXTtcbiAgICBzZXRfdW5pZm9ybShjLCB1bmlmb3JtX2hhbmRsZSwgdW5pZm9ybV9mdW5jdGlvbiwgdmFsdWUpO1xufTtcblxuZ2xpci5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uKGMsIGFyZ3MpIHtcbiAgICB2YXIgcHJvZ3JhbV9pZCA9IGFyZ3NbMF07XG4gICAgdmFyIHNhbXBsZXJfbmFtZSA9IGFyZ3NbMV07XG4gICAgdmFyIHRleHR1cmVfaWQgPSBhcmdzWzJdO1xuXG4gICAgdmFyIHByb2dyYW0gPSBjLl9uc1twcm9ncmFtX2lkXTtcbiAgICB2YXIgcHJvZ3JhbV9oYW5kbGUgPSBwcm9ncmFtLmhhbmRsZTtcbiAgICB2YXIgdGV4dHVyZV9oYW5kbGUgPSBjLl9uc1t0ZXh0dXJlX2lkXS5oYW5kbGU7XG5cbiAgICBpZiAodGV4dHVyZV9oYW5kbGUgPT09IEpVU1RfREVMRVRFRCkge1xuICAgICAgICBkZWJ1ZyhcIlJlbW92aW5nIHRleHR1cmUgJ3swfScgZnJvbSBwcm9ncmFtICd7MX0nXCIuZm9ybWF0KFxuICAgICAgICAgICAgdGV4dHVyZV9pZCwgcHJvZ3JhbV9pZFxuICAgICAgICApKTtcbiAgICAgICAgZGVsZXRlIHByb2dyYW0udGV4dHVyZXNbdGV4dHVyZV9pZF07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWJ1ZyhcIkluaXRpYWxpemluZyB0ZXh0dXJlICd7MH0nIGZvciBwcm9ncmFtICd7MX0nLlwiLmZvcm1hdChcbiAgICAgICAgdGV4dHVyZV9pZCwgcHJvZ3JhbV9pZCkpO1xuXG4gICAgLy8gRklYTUU6IFByb2JhYmx5IHNob3VsZCBzdG9yZSB0ZXh0dXJlcyBieSBzYW1wbGVyIG5hbWUsIG5vdCB0ZXh0dXJlIGlkXG4gICAgaWYgKHByb2dyYW0udGV4dHVyZV91bmlmb3Jtcy5oYXNPd25Qcm9wZXJ0eShzYW1wbGVyX25hbWUpKSB7XG4gICAgICAgIC8vIFRoaXMgcHJvZ3JhbSBoYXMgaGFkIHRoaXMgc2FtcGxlciB1bmlmb3JtIG5hbWUgc2V0IGJlZm9yZVxuICAgICAgICAvLyBMZXQncyByZW1vdmUgdGhlIG9sZCBvbmVcbiAgICAgICAgZGVidWcoJ1JlbW92aW5nIHByZXZpb3VzbHkgYXNzaWduZWQgdGV4dHVyZSBmb3IgXFwnezB9XFwnJy5mb3JtYXQoc2FtcGxlcl9uYW1lKSlcbiAgICAgICAgZGVsZXRlIHByb2dyYW0udGV4dHVyZXNbcHJvZ3JhbS50ZXh0dXJlX3VuaWZvcm1zW3NhbXBsZXJfbmFtZV1dO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgc2FtcGxlciB1bmlmb3JtIHZhbHVlLlxuICAgIHZhciBzYW1wbGVyX2hhbmRsZSA9IGMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW1faGFuZGxlLCBzYW1wbGVyX25hbWUpO1xuICAgIHByb2dyYW0udGV4dHVyZV91bmlmb3Jtc1tzYW1wbGVyX25hbWVdID0gdGV4dHVyZV9pZDtcblxuICAgIGMuX25zW3Byb2dyYW1faWRdLnRleHR1cmVzW3RleHR1cmVfaWRdID0ge1xuICAgICAgICBzYW1wbGVyX25hbWU6IHNhbXBsZXJfbmFtZSxcbiAgICAgICAgc2FtcGxlcl9oYW5kbGU6IHNhbXBsZXJfaGFuZGxlLFxuICAgICAgICBudW1iZXI6IC0xLCAvLyBhc3NpZ25lZCBsYXRlclxuICAgICAgICBoYW5kbGU6IHRleHR1cmVfaGFuZGxlLFxuICAgIH07XG59O1xuXG5nbGlyLnByb3RvdHlwZS5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24oYywgYXJncykge1xuICAgIHZhciB0ZXh0dXJlX2lkID0gYXJnc1swXTtcbiAgICB2YXIgbWluID0gYXJnc1sxXS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBtYWcgPSBhcmdzWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIHRleHR1cmVfaGFuZGxlID0gYy5fbnNbdGV4dHVyZV9pZF0uaGFuZGxlO1xuXG4gICAgdmFyIGdsX3R5cGUgPSBjLmdsLlRFWFRVUkVfMkQ7XG4gICAgYy5nbC5iaW5kVGV4dHVyZShnbF90eXBlLCB0ZXh0dXJlX2hhbmRsZSk7XG4gICAgYy5nbC50ZXhQYXJhbWV0ZXJpKGdsX3R5cGUsIGMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBjLmdsW21pbl0pO1xuICAgIGMuZ2wudGV4UGFyYW1ldGVyaShnbF90eXBlLCBjLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgYy5nbFttYWddKTtcbiAgICBjLmdsLmJpbmRUZXh0dXJlKGdsX3R5cGUsIG51bGwpO1xufTtcblxuZ2xpci5wcm90b3R5cGUud3JhcHBpbmcgPSBmdW5jdGlvbihjLCBhcmdzKSB7XG4gICAgdmFyIHRleHR1cmVfaWQgPSBhcmdzWzBdO1xuICAgIHZhciB3cmFwcGluZyA9IGFyZ3NbMV07XG4gICAgdmFyIHRleHR1cmVfaGFuZGxlID0gYy5fbnNbdGV4dHVyZV9pZF0uaGFuZGxlO1xuXG4gICAgdmFyIGdsX3R5cGUgPSBjLmdsLlRFWFRVUkVfMkQ7XG4gICAgYy5nbC5iaW5kVGV4dHVyZShnbF90eXBlLCB0ZXh0dXJlX2hhbmRsZSk7XG4gICAgYy5nbC50ZXhQYXJhbWV0ZXJpKGdsX3R5cGUsIGMuZ2wuVEVYVFVSRV9XUkFQX1MsXG4gICAgICAgICAgICAgICAgICAgICAgIGMuZ2xbd3JhcHBpbmdbMF0udG9VcHBlckNhc2UoKV0pO1xuICAgIGMuZ2wudGV4UGFyYW1ldGVyaShnbF90eXBlLCBjLmdsLlRFWFRVUkVfV1JBUF9ULFxuICAgICAgICAgICAgICAgICAgICAgICBjLmdsW3dyYXBwaW5nWzFdLnRvVXBwZXJDYXNlKCldKTtcbiAgICBjLmdsLmJpbmRUZXh0dXJlKGdsX3R5cGUsIG51bGwpO1xufTtcblxuZ2xpci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGMsIGFyZ3MpIHtcbiAgICB2YXIgcHJvZ3JhbV9pZCA9IGFyZ3NbMF07XG4gICAgdmFyIG1vZGUgPSBhcmdzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGFyZ3NbMl07XG5cbiAgICB2YXIgcHJvZ3JhbV9oYW5kbGUgPSBjLl9uc1twcm9ncmFtX2lkXS5oYW5kbGU7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBjLl9uc1twcm9ncmFtX2lkXS5hdHRyaWJ1dGVzO1xuICAgIHZhciB0ZXh0dXJlcyA9IGMuX25zW3Byb2dyYW1faWRdLnRleHR1cmVzO1xuICAgIHZhciB0ZXh0dXJlX251bWJlciA9IDA7XG5cbiAgICAvLyBBY3RpdmF0ZSB0aGUgcHJvZ3JhbS5cbiAgICBjLmdsLnVzZVByb2dyYW0ocHJvZ3JhbV9oYW5kbGUpO1xuXG4gICAgLy8gQWN0aXZhdGUgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHByb2dyYW0uXG4gICAgZm9yIChhdHRyaWJ1dGVfbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV9uYW1lXTtcbiAgICAgICAgZGVidWcoXCJBY3RpdmF0aW5nIGF0dHJpYnV0ZSAnezB9JyBmb3IgcHJvZ3JhbSAnezF9Jy5cIi5mb3JtYXQoXG4gICAgICAgICAgICBhdHRyaWJ1dGVfbmFtZSwgcHJvZ3JhbV9pZCkpO1xuICAgICAgICBhY3RpdmF0ZV9hdHRyaWJ1dGUoYywgYXR0cmlidXRlLmhhbmRsZSwgYXR0cmlidXRlLnZib19pZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuc3RyaWRlLCBhdHRyaWJ1dGUub2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBBY3RpdmF0ZSBhbGwgdGV4dHVyZXMgaW4gdGhlIHByb2dyYW0uXG4gICAgZm9yICh0ZXh0dXJlX2lkIGluIHRleHR1cmVzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZXNbdGV4dHVyZV9pZF07XG4gICAgICAgIGlmIChjLl9uc1t0ZXh0dXJlX2lkXS5oYW5kbGUgPT09IEpVU1RfREVMRVRFRCkge1xuICAgICAgICAgICAgZGVidWcoXCJJZ25vcmluZyB0ZXh0dXJlICd7MH0nIGZyb20gcHJvZ3JhbSAnezF9J1wiLmZvcm1hdChcbiAgICAgICAgICAgICAgICB0ZXh0dXJlX2lkLCBwcm9ncmFtX2lkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHRleHR1cmUuaGFuZGxlID0gSlVTVF9ERUxFVEVEO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dHVyZS5udW1iZXIgPSB0ZXh0dXJlX251bWJlcjtcbiAgICAgICAgdGV4dHVyZV9udW1iZXIgKz0gMTtcbiAgICAgICAgZGVidWcoXCJBY3RpdmF0aW5nIHRleHR1cmUgJ3swfScgZm9yIHByb2dyYW0gJ3sxfScgYXMgbnVtYmVyICd7Mn0nLlwiLmZvcm1hdChcbiAgICAgICAgICAgIHRleHR1cmVfaWQsIHByb2dyYW1faWQsIHRleHR1cmUubnVtYmVyKSk7XG4gICAgICAgIGFjdGl2YXRlX3RleHR1cmUoYywgdGV4dHVyZS5oYW5kbGUsIHRleHR1cmUuc2FtcGxlcl9oYW5kbGUsIHRleHR1cmUubnVtYmVyKTtcbiAgICAgICAgYy5nbC51bmlmb3JtMWkodGV4dHVyZS5zYW1wbGVyX2hhbmRsZSwgdGV4dHVyZS5udW1iZXIpO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIHByb2dyYW0uXG4gICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBEcmF3IHRoZSBwcm9ncmFtIHdpdGhvdXQgaW5kZXggYnVmZmVyLlxuICAgICAgICB2YXIgc3RhcnQgPSBzZWxlY3Rpb25bMF07XG4gICAgICAgIHZhciBjb3VudCA9IHNlbGVjdGlvblsxXTtcbiAgICAgICAgZGVidWcoXCJSZW5kZXJpbmcgcHJvZ3JhbSAnezB9JyB3aXRoIHsxfS5cIi5mb3JtYXQoXG4gICAgICAgICAgICBwcm9ncmFtX2lkLCBtb2RlKSk7XG4gICAgICAgIGMuZ2wuZHJhd0FycmF5cyhjLmdsW21vZGVdLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rpb24ubGVuZ3RoID09IDMpIHtcbiAgICAgICAgLy8gRHJhdyB0aGUgcHJvZ3JhbSB3aXRoIGluZGV4IGJ1ZmZlci5cbiAgICAgICAgdmFyIGluZGV4X2J1ZmZlcl9pZCA9IHNlbGVjdGlvblswXTtcbiAgICAgICAgdmFyIGluZGV4X2J1ZmZlcl90eXBlID0gc2VsZWN0aW9uWzFdO1xuICAgICAgICB2YXIgY291bnQgPSBzZWxlY3Rpb25bMl07XG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggYnVmZmVyIGhhbmRsZSBmcm9tIHRoZSBuYW1lc3BhY2UuXG4gICAgICAgIHZhciBpbmRleF9idWZmZXJfaGFuZGxlID0gYy5fbnNbaW5kZXhfYnVmZmVyX2lkXS5oYW5kbGU7XG4gICAgICAgIGRlYnVnKFwiUmVuZGVyaW5nIHByb2dyYW0gJ3swfScgd2l0aCB7MX0gYW5kIGluZGV4IGJ1ZmZlciAnezJ9JyBvZiB0eXBlICd7M30nLlwiLmZvcm1hdChcbiAgICAgICAgICAgIHByb2dyYW1faWQsIG1vZGUsIGluZGV4X2J1ZmZlcl9pZCwgaW5kZXhfYnVmZmVyX3R5cGUpKTtcbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGluZGV4IGJ1ZmZlci5cbiAgICAgICAgYy5nbC5iaW5kQnVmZmVyKGMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4X2J1ZmZlcl9oYW5kbGUpO1xuICAgICAgICBjLmdsLmRyYXdFbGVtZW50cyhjLmdsW21vZGVdLCBjb3VudCwgYy5nbFtpbmRleF9idWZmZXJfdHlwZV0sIDApO1xuICAgIH1cblxuICAgIC8vIERlYWN0aXZhdGUgYXR0cmlidXRlcy5cbiAgICBmb3IgKGF0dHJpYnV0ZV9uYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZGVidWcoXCJEZWFjdGl2YXRpbmcgYXR0cmlidXRlICd7MH0nIGZvciBwcm9ncmFtICd7MX0nLlwiLmZvcm1hdChcbiAgICAgICAgICAgIGF0dHJpYnV0ZV9uYW1lLCBwcm9ncmFtX2lkKSk7XG4gICAgICAgIGRlYWN0aXZhdGVfYXR0cmlidXRlKGMsIGF0dHJpYnV0ZXNbYXR0cmlidXRlX25hbWVdLmhhbmRsZSk7XG4gICAgfVxuXG4gICAgLy8gRGVhY3RpdmF0ZSB0ZXh0dXJlcy5cbiAgICB2YXIgbmV3X3RleHR1cmVzID0ge307XG4gICAgZm9yICh0ZXh0dXJlX2lkIGluIHRleHR1cmVzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZXNbdGV4dHVyZV9pZF07XG4gICAgICAgIGRlYnVnKFwiRGVhY3RpdmF0aW5nIHRleHR1cmUgJ3swfScgZm9yIHByb2dyYW0gJ3sxfScuXCIuZm9ybWF0KFxuICAgICAgICAgICAgdGV4dHVyZV9pZCwgcHJvZ3JhbV9pZCkpO1xuICAgICAgICBkZWFjdGl2YXRlX3RleHR1cmUoYywgdGV4dHVyZS5oYW5kbGUsIHRleHR1cmUuc2FtcGxlcl9oYW5kbGUsIHRleHR1cmUubnVtYmVyKTtcblxuICAgICAgICAvLyBEb24ndCBpbmNsdWRlIGFueSBvZiB0aGUgdGV4dHVyZXMgdGhhdCB3ZXJlIGRlbGV0ZWQgaW4gdGhpcyBwcm9ncmFtXG4gICAgICAgIGlmIChjLl9uc1t0ZXh0dXJlX2lkXS5oYW5kbGUgIT0gSlVTVF9ERUxFVEVEKSB7XG4gICAgICAgICAgICBuZXdfdGV4dHVyZXNbdGV4dHVyZV9pZF0gPSB0ZXh0dXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGMuX25zW3Byb2dyYW1faWRdLnRleHR1cmVzID0gbmV3X3RleHR1cmVzO1xufTtcblxuZ2xpci5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oYywgYXJncykge1xuICAgIC8vIGZyYW1lYnVmZmVyIG9yIHNoYWRlciBvYmplY3QgSURcbiAgICB2YXIgZHN0X2lkID0gYXJnc1swXTtcbiAgICB2YXIgZHN0X29iaiA9IGMuX25zW2RzdF9pZF07XG4gICAgdmFyIGRzdF90eXBlID0gZHN0X29iai5vYmplY3RfdHlwZTtcbiAgICB2YXIgZHN0X2hhbmRsZSA9IGRzdF9vYmouaGFuZGxlO1xuICAgIGlmIChkc3RfdHlwZSA9PSAnUHJvZ3JhbScpIHtcbiAgICAgICAgLy8gYXR0YWNoaW5nIHRvIHByb2dyYW0sIG11c3QgYmUgYSBzaGFkZXIgd2UncmUgYXR0YWNoaW5nXG4gICAgICAgIHZhciBzaGFkZXJfaWQgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgc2hhZGVyX2hhbmRsZSA9IGMuX25zW3NoYWRlcl9pZF0uaGFuZGxlO1xuICAgICAgICBjLmdsLmF0dGFjaFNoYWRlcihkc3RfaGFuZGxlLCBzaGFkZXJfaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCB0byBmcmFtZWJ1ZmZlclxuICAgIHZhciBvYmplY3RfaWQgPSBhcmdzWzJdO1xuICAgIHZhciBhdHRhY2hfdHlwZSA9IGMuZ2xbZ2V0X2F0dGFjaG1lbnRfdHlwZShhcmdzWzFdKV07XG4gICAgdmFyIG9iamVjdDtcbiAgICBhY3RpdmF0ZV9mcmFtZWJ1ZmZlcihjLCBkc3RfaWQpO1xuICAgIGlmIChvYmplY3RfaWQgPT0gMCkge1xuICAgICAgICBkZWJ1ZygnQXR0YWNoaW5nIFJlbmRlckJ1ZmZlciBvYmplY3QgezB9IHRvIGZyYW1lYnVmZmVyIHsxfScuZm9ybWF0KG9iamVjdF9pZCwgZHN0X2lkKSk7XG4gICAgICAgIGMuZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYy5nbC5GUkFNRUJVRkZFUiwgYXR0YWNoX3R5cGUsIGMuZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QgPSBjLl9uc1tvYmplY3RfaWRdO1xuICAgICAgICBkZWJ1ZygnQXR0YWNoaW5nIHswfSBvYmplY3QgezF9IHRvIGZyYW1lYnVmZmVyIHsyfSBmb3IgezN9Jy5mb3JtYXQob2JqZWN0Lm9iamVjdF90eXBlLCBvYmplY3RfaWQsIGRzdF9pZCwgYXJnc1sxXSkpO1xuICAgICAgICBpZiAob2JqZWN0Lm9iamVjdF90eXBlID09ICdSZW5kZXJCdWZmZXInKSB7XG4gICAgICAgICAgICBjLmdsLmJpbmRSZW5kZXJidWZmZXIoYy5nbC5SRU5ERVJCVUZGRVIsIG9iamVjdC5oYW5kbGUpO1xuICAgICAgICAgICAgYy5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihjLmdsLkZSQU1FQlVGRkVSLCBhdHRhY2hfdHlwZSwgYy5nbC5SRU5ERVJCVUZGRVIsIG9iamVjdC5oYW5kbGUpO1xuICAgICAgICAgICAgYy5nbC5iaW5kUmVuZGVyYnVmZmVyKGMuZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmplY3Qub2JqZWN0X3R5cGUgPT0gJ1RleHR1cmUyRCcpIHtcbiAgICAgICAgICAgIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAob2JqZWN0LnNoYXBlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ1NldHRpbmcgZW1wdHkgdGV4dHVyZSBkYXRhIHRvIHVuc2V0IHRleHR1cmUgYmVmb3JlIGF0dGFjaGluZyB0byBmcmFtZWJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIHNldF90ZXh0dXJlX2RhdGEoYywgb2JqZWN0LmhhbmRsZSwgYy5nbC5URVhUVVJFXzJELFxuICAgICAgICAgICAgICAgICAgICBjLmdsW29iamVjdC5mb3JtYXRdLCBvYmplY3Quc2l6ZVsxXSwgb2JqZWN0LnNpemVbMF0sIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSU5GTzogMCBpcyBmb3IgbWlwbWFwIGxldmVsIDAgKGRlZmF1bHQpIG9mIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICBjLmdsLmJpbmRUZXh0dXJlKGMuZ2wuVEVYVFVSRV8yRCwgb2JqZWN0LmhhbmRsZSk7XG4gICAgICAgICAgICBjLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGMuZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaF90eXBlLCBjLmdsLlRFWFRVUkVfMkQsIG9iamVjdC5oYW5kbGUsIDApO1xuICAgICAgICAgICAgYy5nbC5iaW5kVGV4dHVyZShjLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGMuX25zW2RzdF9pZF0udmFsaWRhdGVkID0gZmFsc2U7XG4gICAgZGVhY3RpdmF0ZV9mcmFtZWJ1ZmZlcihjLCBkc3RfaWQpO1xufTtcblxuZ2xpci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGMsIGFyZ3MpIHtcbiAgICB2YXIgcHJvZ3JhbV9oYW5kbGUgPSBjLl9uc1thcmdzWzBdXS5oYW5kbGU7XG4gICAgYy5nbC5saW5rUHJvZ3JhbShwcm9ncmFtX2hhbmRsZSk7XG5cbiAgICBpZiAoIWMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtX2hhbmRsZSwgYy5nbC5MSU5LX1NUQVRVUykpXG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgaW5pdGlhbGlzZSBzaGFkZXJzIG9uIHByb2dyYW0gJ3swfScuXCIuZm9ybWF0KHByb2dyYW1faGFuZGxlKSk7XG4gICAgfVxufTtcblxuZ2xpci5wcm90b3R5cGUuZnJhbWVidWZmZXIgPSBmdW5jdGlvbihjLCBhcmdzKSB7XG4gICAgdmFyIGZyYW1lYnVmZmVyX2lkID0gYXJnc1swXTtcbiAgICB2YXIgYmluZCA9IGFyZ3NbMV07XG4gICAgdmFyIGZiID0gYy5fbnNbZnJhbWVidWZmZXJfaWRdO1xuXG4gICAgaWYgKGJpbmQpIHtcbiAgICAgICAgZGVidWcoJ0JpbmRpbmcgZnJhbWVidWZmZXIgezB9Jy5mb3JtYXQoZnJhbWVidWZmZXJfaWQpKTtcbiAgICAgICAgYWN0aXZhdGVfZnJhbWVidWZmZXIoYywgZnJhbWVidWZmZXJfaWQpO1xuICAgICAgICBpZiAoIWZiLnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgZmIudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbGlkYXRlX2ZyYW1lYnVmZmVyKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWJ1ZygnVW5iaW5kaW5nIGZyYW1lYnVmZmVyIHswfScuZm9ybWF0KGZyYW1lYnVmZmVyX2lkKSk7XG4gICAgICAgIGRlYWN0aXZhdGVfZnJhbWVidWZmZXIoYywgZnJhbWVidWZmZXJfaWQpO1xuICAgIH1cbn07XG5cbmdsaXIucHJvdG90eXBlLmZ1bmMgPSBmdW5jdGlvbihjLCBhcmdzKSB7XG4gICAgdmFyIG5hbWUgPSBhcmdzWzBdO1xuICAgIGRlYnVnKFwiQ2FsbGluZyB7MH0oezF9KS5cIi5mb3JtYXQobmFtZSwgYXJncy5zbGljZSgxKSkpO1xuXG4gICAgLy8gSGFuZGxlIGVudW1zOiByZXBsYWNlIHN0cmluZ3MgYnkgZ2xvYmFsIEdMIHZhcmlhYmxlcy5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXJnc1tpXSA9IHBhcnNlX2VudW0oYywgYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnVuYyA9IGMuZ2xbbmFtZV07XG4gICAgdmFyIGZ1bmNfYXJncyA9IGFyZ3Muc2xpY2UoMSk7XG4gICAgZnVuYy5hcHBseShjLmdsLCBmdW5jX2FyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgZ2xpcigpO1xuIiwidmFyIGdsaXIgPSByZXF1aXJlKCcuL2dsb28uZ2xpci5qcycpO1xuXG5mdW5jdGlvbiBpbml0X3dlYmdsKGMpIHtcbiAgICAvLyBHZXQgdGhlIERPTSBvYmplY3QsIG5vdCB0aGUgalF1ZXJ5IG9uZS5cbiAgICB2YXIgY2FudmFzID0gYy4kZWwuZ2V0KDApO1xuICAgIGMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpIHx8XG4gICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIpO1xuICAgIHZhciBleHQgPSBjLmdsLmdldEV4dGVuc2lvbignT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJykgfHwgYy5nbC5nZXRFeHRlbnNpb24oJ01PWl9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKSB8fCBjLmdsLmdldEV4dGVuc2lvbignV0VCS0lUX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpO1xuICAgIGlmIChleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFeHRlbnNpb24gXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBTb21lIGZlYXR1cmVzIG1heSBub3Qgd29yayBhcyBleHBlY3RlZCcpO1xuICAgIH1cbiAgICB2YXIgZXh0ID0gYy5nbC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSB8fFxuICAgICAgICBjLmdsLmdldEV4dGVuc2lvbignTU9aX09FU19lbGVtZW50X2luZGV4X3VpbnQnKSB8fFxuICAgICAgICBjLmdsLmdldEV4dGVuc2lvbignV0VCS0lUX09FU19lbGVtZW50X2luZGV4X3VpbnQnKTtcbiAgICBpZiAoZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXh0ZW5zaW9uIFxcJ09FU19lbGVtZW50X2luZGV4X3VpbnRcXCcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFNvbWUgZmVhdHVyZXMgbWF5IG5vdCB3b3JrIGFzIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIHZhciBleHQgPSBjLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAvLyB8fFxuICAgIC8vICAgICBjLmdsLmdldEV4dGVuc2lvbignTU9aX09FU19lbGVtZW50X2luZGV4X3VpbnQnKSB8fFxuICAgIC8vICAgICBjLmdsLmdldEV4dGVuc2lvbignV0VCS0lUX09FU19lbGVtZW50X2luZGV4X3VpbnQnKTtcbiAgICBpZiAoZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXh0ZW5zaW9uIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBTb21lIGZlYXR1cmVzIG1heSBub3Qgd29yayBhcyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIHZhciBleHQgPSBjLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyk7XG4gICAgaWYgKGV4dCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4dGVuc2lvbiBcXCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcXCcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFNvbWUgZmVhdHVyZXMgbWF5IG5vdCB3b3JrIGFzIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgLy8gYy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnKTtcbn1cblxuXG4vKiBDcmVhdGlvbiBvZiB2aXNweS5nbG9vICovXG52YXIgZ2xvbyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2xpciA9IGdsaXI7XG4gICAgLy8gQ29uc3RydWN0b3IuXG5cbn07XG5cbmdsb28ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihjKSB7XG4gICAgaW5pdF93ZWJnbChjKTtcbiAgICB0aGlzLmdsaXIuaW5pdChjKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgZ2xvbygpO1xuIiwiLyohIENvcHlyaWdodCAoYykgMjAxMyBCcmFuZG9uIEFhcm9uIChodHRwOi8vYnJhbmRvbi5hYXJvbi5zaClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTElDRU5TRS50eHQpLlxuICpcbiAqIFZlcnNpb246IDMuMS4xMlxuICpcbiAqIFJlcXVpcmVzOiBqUXVlcnkgMS4yLjIrXG4gKi9cbiFmdW5jdGlvbihhKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImpxdWVyeVwiXSxhKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1hOmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXt2YXIgZz1ifHx3aW5kb3cuZXZlbnQsaD1pLmNhbGwoYXJndW1lbnRzLDEpLGo9MCxsPTAsbT0wLG49MCxvPTAscD0wO2lmKGI9YS5ldmVudC5maXgoZyksYi50eXBlPVwibW91c2V3aGVlbFwiLFwiZGV0YWlsXCJpbiBnJiYobT0tMSpnLmRldGFpbCksXCJ3aGVlbERlbHRhXCJpbiBnJiYobT1nLndoZWVsRGVsdGEpLFwid2hlZWxEZWx0YVlcImluIGcmJihtPWcud2hlZWxEZWx0YVkpLFwid2hlZWxEZWx0YVhcImluIGcmJihsPS0xKmcud2hlZWxEZWx0YVgpLFwiYXhpc1wiaW4gZyYmZy5heGlzPT09Zy5IT1JJWk9OVEFMX0FYSVMmJihsPS0xKm0sbT0wKSxqPTA9PT1tP2w6bSxcImRlbHRhWVwiaW4gZyYmKG09LTEqZy5kZWx0YVksaj1tKSxcImRlbHRhWFwiaW4gZyYmKGw9Zy5kZWx0YVgsMD09PW0mJihqPS0xKmwpKSwwIT09bXx8MCE9PWwpe2lmKDE9PT1nLmRlbHRhTW9kZSl7dmFyIHE9YS5kYXRhKHRoaXMsXCJtb3VzZXdoZWVsLWxpbmUtaGVpZ2h0XCIpO2oqPXEsbSo9cSxsKj1xfWVsc2UgaWYoMj09PWcuZGVsdGFNb2RlKXt2YXIgcj1hLmRhdGEodGhpcyxcIm1vdXNld2hlZWwtcGFnZS1oZWlnaHRcIik7aio9cixtKj1yLGwqPXJ9aWYobj1NYXRoLm1heChNYXRoLmFicyhtKSxNYXRoLmFicyhsKSksKCFmfHxmPm4pJiYoZj1uLGQoZyxuKSYmKGYvPTQwKSksZChnLG4pJiYoai89NDAsbC89NDAsbS89NDApLGo9TWF0aFtqPj0xP1wiZmxvb3JcIjpcImNlaWxcIl0oai9mKSxsPU1hdGhbbD49MT9cImZsb29yXCI6XCJjZWlsXCJdKGwvZiksbT1NYXRoW20+PTE/XCJmbG9vclwiOlwiY2VpbFwiXShtL2YpLGsuc2V0dGluZ3Mubm9ybWFsaXplT2Zmc2V0JiZ0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCl7dmFyIHM9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtvPWIuY2xpZW50WC1zLmxlZnQscD1iLmNsaWVudFktcy50b3B9cmV0dXJuIGIuZGVsdGFYPWwsYi5kZWx0YVk9bSxiLmRlbHRhRmFjdG9yPWYsYi5vZmZzZXRYPW8sYi5vZmZzZXRZPXAsYi5kZWx0YU1vZGU9MCxoLnVuc2hpZnQoYixqLGwsbSksZSYmY2xlYXJUaW1lb3V0KGUpLGU9c2V0VGltZW91dChjLDIwMCksKGEuZXZlbnQuZGlzcGF0Y2h8fGEuZXZlbnQuaGFuZGxlKS5hcHBseSh0aGlzLGgpfX1mdW5jdGlvbiBjKCl7Zj1udWxsfWZ1bmN0aW9uIGQoYSxiKXtyZXR1cm4gay5zZXR0aW5ncy5hZGp1c3RPbGREZWx0YXMmJlwibW91c2V3aGVlbFwiPT09YS50eXBlJiZiJTEyMD09PTB9dmFyIGUsZixnPVtcIndoZWVsXCIsXCJtb3VzZXdoZWVsXCIsXCJET01Nb3VzZVNjcm9sbFwiLFwiTW96TW91c2VQaXhlbFNjcm9sbFwiXSxoPVwib253aGVlbFwiaW4gZG9jdW1lbnR8fGRvY3VtZW50LmRvY3VtZW50TW9kZT49OT9bXCJ3aGVlbFwiXTpbXCJtb3VzZXdoZWVsXCIsXCJEb21Nb3VzZVNjcm9sbFwiLFwiTW96TW91c2VQaXhlbFNjcm9sbFwiXSxpPUFycmF5LnByb3RvdHlwZS5zbGljZTtpZihhLmV2ZW50LmZpeEhvb2tzKWZvcih2YXIgaj1nLmxlbmd0aDtqOylhLmV2ZW50LmZpeEhvb2tzW2dbLS1qXV09YS5ldmVudC5tb3VzZUhvb2tzO3ZhciBrPWEuZXZlbnQuc3BlY2lhbC5tb3VzZXdoZWVsPXt2ZXJzaW9uOlwiMy4xLjEyXCIsc2V0dXA6ZnVuY3Rpb24oKXtpZih0aGlzLmFkZEV2ZW50TGlzdGVuZXIpZm9yKHZhciBjPWgubGVuZ3RoO2M7KXRoaXMuYWRkRXZlbnRMaXN0ZW5lcihoWy0tY10sYiwhMSk7ZWxzZSB0aGlzLm9ubW91c2V3aGVlbD1iO2EuZGF0YSh0aGlzLFwibW91c2V3aGVlbC1saW5lLWhlaWdodFwiLGsuZ2V0TGluZUhlaWdodCh0aGlzKSksYS5kYXRhKHRoaXMsXCJtb3VzZXdoZWVsLXBhZ2UtaGVpZ2h0XCIsay5nZXRQYWdlSGVpZ2h0KHRoaXMpKX0sdGVhcmRvd246ZnVuY3Rpb24oKXtpZih0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIpZm9yKHZhciBjPWgubGVuZ3RoO2M7KXRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihoWy0tY10sYiwhMSk7ZWxzZSB0aGlzLm9ubW91c2V3aGVlbD1udWxsO2EucmVtb3ZlRGF0YSh0aGlzLFwibW91c2V3aGVlbC1saW5lLWhlaWdodFwiKSxhLnJlbW92ZURhdGEodGhpcyxcIm1vdXNld2hlZWwtcGFnZS1oZWlnaHRcIil9LGdldExpbmVIZWlnaHQ6ZnVuY3Rpb24oYil7dmFyIGM9YShiKSxkPWNbXCJvZmZzZXRQYXJlbnRcImluIGEuZm4/XCJvZmZzZXRQYXJlbnRcIjpcInBhcmVudFwiXSgpO3JldHVybiBkLmxlbmd0aHx8KGQ9YShcImJvZHlcIikpLHBhcnNlSW50KGQuY3NzKFwiZm9udFNpemVcIiksMTApfHxwYXJzZUludChjLmNzcyhcImZvbnRTaXplXCIpLDEwKXx8MTZ9LGdldFBhZ2VIZWlnaHQ6ZnVuY3Rpb24oYil7cmV0dXJuIGEoYikuaGVpZ2h0KCl9LHNldHRpbmdzOnthZGp1c3RPbGREZWx0YXM6ITAsbm9ybWFsaXplT2Zmc2V0OiEwfX07YS5mbi5leHRlbmQoe21vdXNld2hlZWw6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/dGhpcy5iaW5kKFwibW91c2V3aGVlbFwiLGEpOnRoaXMudHJpZ2dlcihcIm1vdXNld2hlZWxcIil9LHVubW91c2V3aGVlbDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy51bmJpbmQoXCJtb3VzZXdoZWVsXCIsYSl9fSl9KTsiLCIvKiFcbiogc2NyZWVuZnVsbFxuKiB2MS4yLjAgLSAyMDE0LTA0LTI5XG4qIChjKSBTaW5kcmUgU29yaHVzOyBNSVQgTGljZW5zZVxuKi9cbiFmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBhPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzLGI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEVsZW1lbnQmJlwiQUxMT1dfS0VZQk9BUkRfSU5QVVRcImluIEVsZW1lbnQsYz1mdW5jdGlvbigpe2Zvcih2YXIgYSxiLGM9W1tcInJlcXVlc3RGdWxsc2NyZWVuXCIsXCJleGl0RnVsbHNjcmVlblwiLFwiZnVsbHNjcmVlbkVsZW1lbnRcIixcImZ1bGxzY3JlZW5FbmFibGVkXCIsXCJmdWxsc2NyZWVuY2hhbmdlXCIsXCJmdWxsc2NyZWVuZXJyb3JcIl0sW1wid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW5cIixcIndlYmtpdEV4aXRGdWxsc2NyZWVuXCIsXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiLFwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWRcIixcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwiXSxbXCJ3ZWJraXRSZXF1ZXN0RnVsbFNjcmVlblwiLFwid2Via2l0Q2FuY2VsRnVsbFNjcmVlblwiLFwid2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50XCIsXCJ3ZWJraXRDYW5jZWxGdWxsU2NyZWVuXCIsXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsXCJ3ZWJraXRmdWxsc2NyZWVuZXJyb3JcIl0sW1wibW96UmVxdWVzdEZ1bGxTY3JlZW5cIixcIm1vekNhbmNlbEZ1bGxTY3JlZW5cIixcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCIsXCJtb3pGdWxsU2NyZWVuRW5hYmxlZFwiLFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFwibW96ZnVsbHNjcmVlbmVycm9yXCJdLFtcIm1zUmVxdWVzdEZ1bGxzY3JlZW5cIixcIm1zRXhpdEZ1bGxzY3JlZW5cIixcIm1zRnVsbHNjcmVlbkVsZW1lbnRcIixcIm1zRnVsbHNjcmVlbkVuYWJsZWRcIixcIk1TRnVsbHNjcmVlbkNoYW5nZVwiLFwiTVNGdWxsc2NyZWVuRXJyb3JcIl1dLGQ9MCxlPWMubGVuZ3RoLGY9e307ZT5kO2QrKylpZihhPWNbZF0sYSYmYVsxXWluIGRvY3VtZW50KXtmb3IoZD0wLGI9YS5sZW5ndGg7Yj5kO2QrKylmW2NbMF1bZF1dPWFbZF07cmV0dXJuIGZ9cmV0dXJuITF9KCksZD17cmVxdWVzdDpmdW5jdGlvbihhKXt2YXIgZD1jLnJlcXVlc3RGdWxsc2NyZWVuO2E9YXx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LC81XFwuMVtcXC5cXGRdKiBTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk/YVtkXSgpOmFbZF0oYiYmRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCl9LGV4aXQ6ZnVuY3Rpb24oKXtkb2N1bWVudFtjLmV4aXRGdWxsc2NyZWVuXSgpfSx0b2dnbGU6ZnVuY3Rpb24oYSl7dGhpcy5pc0Z1bGxzY3JlZW4/dGhpcy5leGl0KCk6dGhpcy5yZXF1ZXN0KGEpfSxvbmNoYW5nZTpmdW5jdGlvbigpe30sb25lcnJvcjpmdW5jdGlvbigpe30scmF3OmN9O3JldHVybiBjPyhPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkLHtpc0Z1bGxzY3JlZW46e2dldDpmdW5jdGlvbigpe3JldHVybiEhZG9jdW1lbnRbYy5mdWxsc2NyZWVuRWxlbWVudF19fSxlbGVtZW50OntlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudFtjLmZ1bGxzY3JlZW5FbGVtZW50XX19LGVuYWJsZWQ6e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuISFkb2N1bWVudFtjLmZ1bGxzY3JlZW5FbmFibGVkXX19fSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihjLmZ1bGxzY3JlZW5jaGFuZ2UsZnVuY3Rpb24oYSl7ZC5vbmNoYW5nZS5jYWxsKGQsYSl9KSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGMuZnVsbHNjcmVlbmVycm9yLGZ1bmN0aW9uKGEpe2Qub25lcnJvci5jYWxsKGQsYSl9KSx2b2lkKGE/bW9kdWxlLmV4cG9ydHM9ZDp3aW5kb3cuc2NyZWVuZnVsbD1kKSk6dm9pZChhP21vZHVsZS5leHBvcnRzPSExOndpbmRvdy5zY3JlZW5mdWxsPSExKX0oKTsiLCJpZiAoIVN0cmluZy5wcm90b3R5cGUuZm9ybWF0KSB7XG4gIFN0cmluZy5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSgveyhcXGQrKX0vZywgZnVuY3Rpb24obWF0Y2gsIG51bWJlcikge1xuICAgICAgcmV0dXJuICh0eXBlb2YgYXJnc1tudW1iZXJdICE9ICd1bmRlZmluZWQnKVxuICAgICAgICA/IGFyZ3NbbnVtYmVyXVxuICAgICAgICA6IG1hdGNoO1xuICAgIH0pO1xuICB9O1xufVxuXG5pZih0eXBlb2YoU3RyaW5nLnByb3RvdHlwZS50cmltKSA9PT0gXCJ1bmRlZmluZWRcIilcbntcbiAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc19hcnJheSh4KSB7XG4gICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XScpO1xufVxuXG5BcnJheS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgLy8gaWYgdGhlIG90aGVyIGFycmF5IGlzIGEgZmFsc3kgdmFsdWUsIHJldHVyblxuICAgIGlmICghYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGNvbXBhcmUgbGVuZ3RocyAtIGNhbiBzYXZlIGEgbG90IG9mIHRpbWVcbiAgICBpZiAodGhpcy5sZW5ndGggIT0gYXJyYXkubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbD10aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIG5lc3RlZCBhcnJheXNcbiAgICAgICAgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBBcnJheSAmJiBhcnJheVtpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyByZWN1cnNlIGludG8gdGhlIG5lc3RlZCBhcnJheXNcbiAgICAgICAgICAgIGlmICghdGhpc1tpXS5lcXVhbHMoYXJyYXlbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzW2ldICE9IGFycmF5W2ldKSB7XG4gICAgICAgICAgICAvLyBXYXJuaW5nIC0gdHdvIGRpZmZlcmVudCBvYmplY3QgaW5zdGFuY2VzIHdpbGwgbmV2ZXIgYmUgZXF1YWw6IHt4OjIwfSAhPSB7eDoyMH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmlmICh0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoICE9ICdmdW5jdGlvbicpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cil7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgc3RyLmxlbmd0aCkgPT0gc3RyO1xuICB9O1xufVxuXG53aW5kb3cuVklTUFlfREVCVUcgPSBmYWxzZTtcbmZ1bmN0aW9uIGRlYnVnKG1zZykge1xuICAgIGlmICh3aW5kb3cuVklTUFlfREVCVUcpe1xuICAgICAgICBjb25zb2xlLmRlYnVnKG1zZyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtkZWJ1ZzogZGVidWd9O1xuIiwidmFyIHNjcmVlbmZ1bCA9IHJlcXVpcmUoXCIuL2xpYi9zY3JlZW5mdWxsLm1pbi5qc1wiKTtcbnZhciBWaXNweUNhbnZhcyA9IHJlcXVpcmUoJy4vdmlzcHljYW52YXMuanMnKTtcbnZhciBnbG9vID0gcmVxdWlyZSgnLi9nbG9vLmpzJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMuanMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsLmpzJyk7XG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vZGF0YS5qcycpO1xucmVxdWlyZShcIi4vbGliL2pxdWVyeS5tb3VzZXdoZWVsLm1pbi5qc1wiKSgkKTtcblxudmFyIFZpc3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ29uc3RydWN0b3Igb2YgdGhlIFZpc3B5IGxpYnJhcnkuXG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5nbG9vID0gZ2xvbztcbiAgICB0aGlzLl9pc19sb29wX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAvLyBMaXN0IG9mIGNhbnZhc2VzIG9uIHRoZSBwYWdlLlxuICAgIHRoaXMuX2NhbnZhc2VzID0gW107XG59O1xuXG5WaXNweS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGNhbnZhc19pZCkge1xuICAgIHZhciBjYW52YXNfZWw7XG4gICAgY2FudmFzX2VsID0gJChjYW52YXNfaWQpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGNhbnZhcy5cbiAgICB2YXIgY2FudmFzID0gbmV3IFZpc3B5Q2FudmFzKGNhbnZhc19lbCk7XG5cbiAgICBjYW52YXMuZGVhY3RpdmF0ZV9jb250ZXh0X21lbnUoKTtcblxuICAgIC8vIEluaXRpYWxpemUgZXZlbnRzLlxuICAgIHRoaXMuZXZlbnRzLmluaXQoY2FudmFzKTtcblxuICAgIC8vIEluaXRpYWxpemUgV2ViR0wuXG4gICAgdGhpcy5nbG9vLmluaXQoY2FudmFzKTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBjYW52YXMuXG4gICAgdGhpcy5yZWdpc3RlcihjYW52YXMpO1xuXG4gICAgcmV0dXJuIGNhbnZhcztcbn07XG5cblZpc3B5LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIC8qIFJlZ2lzdGVyIGEgY2FudmFzLiAqL1xuICAgIHRoaXMuX2NhbnZhc2VzLnB1c2goY2FudmFzKTtcbiAgICAvLyBjb25zb2xlLmRlYnVnKFwiUmVnaXN0ZXIgY2FudmFzXCIsIGNhbnZhcyk7XG59O1xuXG5WaXNweS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIC8qIFVucmVnaXN0ZXIgYSBjYW52YXMuICovXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fY2FudmFzZXMuaW5kZXhPZihjYW52YXMpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUuZGVidWcoXCJVbnJlZ2lzdGVyIGNhbnZhc1wiLCBjYW52YXMpO1xufTtcblxuXG4vKiBFdmVudCBsb29wICovXG5WaXNweS5wcm90b3R5cGUuc3RhcnRfZXZlbnRfbG9vcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gRG8gbm90IHN0YXJ0IHRoZSBldmVudCBsb29wIHR3aWNlLlxuICAgIGlmICh0aGlzLl9pc19sb29wX3J1bm5pbmcpIHJldHVybjtcblxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbihjKXtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoYywgMTAwMC4gLyA2MC4pO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgLy8gXCJ0aGF0XCIgaXMgdGhlIGN1cnJlbnQgVmlzcHkgaW5zdGFuY2UuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIChmdW5jdGlvbiBhbmltbG9vcCgpIHtcbiAgICAgICAgdGhhdC5fcmVxdWVzdF9pZCA9IHJlcXVlc3RBbmltRnJhbWUoYW5pbWxvb3ApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2FsbCBldmVudF90aWNrKCkgb24gYWxsIGFjdGl2ZSBjYW52YXNlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5fY2FudmFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jYW52YXNlc1tpXS5ldmVudF90aWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICB0aGF0LnN0b3BfZXZlbnRfbG9vcCgpO1xuICAgICAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgdGhpcy5faXNfbG9vcF9ydW5uaW5nID0gdHJ1ZTtcbiAgICBjb25zb2xlLmRlYnVnKFwiRXZlbnQgbG9vcCBzdGFydGVkLlwiKTtcbn07XG5cblZpc3B5LnByb3RvdHlwZS5zdG9wX2V2ZW50X2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdF9pZCk7XG4gICAgdGhpcy5faXNfbG9vcF9ydW5uaW5nID0gZmFsc2U7XG4gICAgY29uc29sZS5kZWJ1ZyhcIkV2ZW50IGxvb3Agc3RvcHBlZC5cIik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFZpc3B5KCk7XG4iLCJcbnZhciBWaXNweUNhbnZhcyA9IGZ1bmN0aW9uICgkZWwpIHtcbiAgICB0aGlzLiRlbCA9ICRlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlzcHlDYW52YXM7XG4iXX0=\n","\"use strict\";\n\nvar widgets = require('@jupyter-widgets/base');\nvar vispy = require('./vispy.min.js');\n\nfunction _inline_glir_commands(commands, buffers) {\n    // Put back the buffers within the GLIR commands before passing them\n    // to the GLIR JavaScript interpretor.\n    for (var i = 0; i < commands.length; i++) {\n        var command = commands[i];\n        // Shader data commands are 3 elements, everything else 4\n        if (command[0] == 'DATA') {\n            console.info(command);\n            if (command[3].shape !== undefined) {\n                // already handled\n                console.info(\"Skipping message processing, already handled...\");\n                continue;\n            }\n            var buffer_index = command[3]['buffer_index'];\n            var buffer_shape = command[3]['buffer_shape'];\n            var buffer_dtype = command[3]['buffer_dtype'];\n            command[3] = buffers[buffer_index];\n            // Add shape and type information to buffer object\n            command[3].shape = buffer_shape;\n            command[3].dtype = buffer_dtype;\n        }\n    }\n    return commands;\n}\n\n// var vispy = require(\"/nbextensions/vispy/vispy.min.js\");\n// var widget, control;\n// try {\n//     widget = require(\"@jupyter-widgets/base\");\n//     control = require(\"@jupyter-widgets/controls\");\n// } catch (e) {\n//     console.warn(\"Importing old ipywidgets <7.0\");\n//     widget = require(\"jupyter-js-widgets\");\n// }\n\nvar VispyView = widgets.DOMWidgetView.extend({\n\n        initialize: function (parameters) {\n            VispyView.__super__.initialize.apply(this, [parameters]);\n\n            this.model.on('msg:custom', this.on_msg, this);\n\n            // Track canvas size changes.\n            this.model.on('change:width', this.size_changed, this);\n            this.model.on('change:height', this.size_changed, this);\n        },\n\n        render: function() {\n            var that = this;\n\n            var canvas = $('<canvas></canvas>');\n            // canvas.css('border', '1px solid rgb(171, 171, 171)');\n            canvas.css('background-color', '#000');\n            canvas.attr('tabindex', '1');\n            this.$el.append(canvas);\n            this.$canvas = canvas;\n\n            // Initialize the VispyCanvas.\n            this.c = vispy.init(canvas);\n\n            this.c.on_resize(function (e) {\n                that.model.set('width', e.size[0]);\n                that.model.set('height', e.size[1]);\n                that.touch();\n            });\n\n            // Start the event loop.\n            this.c.on_event_tick(function() {\n                // This callback function will be called at each JS tick,\n                // before the GLIR commands are flushed.\n\n                // Retrieve and flush the event queue.\n                var events = that.c.event_queue.get();\n\n                that.c.event_queue.clear();\n                // Send the events if the queue is not empty.\n                if (events.length > 0) {\n                    // Create the message.\n                    var msg = {\n                        msg_type: 'events',\n                        contents: events\n                    };\n                    // console.debug(events);\n                    // Send the message with the events to Python.\n                    that.send(msg);\n                }\n            });\n\n            vispy.start_event_loop();\n            var msg = { msg_type: 'init' };\n            this.send(msg);\n            // Make sure the size is correctly set up upon first display.\n            this.size_changed();\n            this.c.resize();\n            this.c.resizable();\n        },\n\n        on_msg: function(msg, buffers) {\n            if (msg == undefined) return;\n            // Receive and execute the GLIR commands.\n            if (msg.msg_type == 'glir_commands') {\n                var commands = msg.commands;\n                // Get the buffers messages.\n                if (msg.array_serialization == 'base64') {\n                    var buffers_msg = msg.buffers;\n                } else if (msg.array_serialization == 'binary') {\n                    // Need to put the raw binary buffers in JavaScript\n                    // objects for the inline commands.\n                    var buffers_msg = [];\n                    for (var i = 0; i < buffers.length; i++) {\n                        buffers_msg[i] = {\n                            'storage_type': 'binary',\n                            'buffer': buffers[i]\n                        };\n                    }\n                }\n\n                // Make the GLIR commands ready for the JavaScript parser\n                // by inlining the buffers.\n                console.log(\"on_msg: %s : %s\", msg.msg_type, msg.commands);\n                var commands_inlined = _inline_glir_commands(commands, buffers_msg);\n                for (var i = 0; i < commands_inlined.length; i++) {\n                    var command = commands[i];\n                    console.debug(command);\n                    this.c.command(command);\n                }\n            }\n        },\n\n        // When the model's size changes.\n        size_changed: function() {\n            var size = [this.model.get('width'), this.model.get('height')];\n            this.$canvas.css('width', size[0] + 'px');\n            this.$canvas.css('height', size[1] + 'px');\n        },\n\n        remove: function() {\n            vispy.unregister(this.c);\n            // Inform Python that the widget has been removed.\n            this.send({\n                msg_type: 'status',\n                contents: 'removed'\n            });\n        }\n    });\n\n\nmodule.exports = {\n    VispyView: VispyView\n};","module.exports = __WEBPACK_EXTERNAL_MODULE__jupyter_widgets_base__;"],"sourceRoot":""}