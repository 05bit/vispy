# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
Normal components are modular shader components used for retrieving or
generating surface normal vectors.

These components generate a function in the fragment shader that accepts no
arguments and returns a vec4 normal vector. Typically, the normal vector
is computed in the vertex shader and passed by varying to the fragment 
shader.
"""

from __future__ import division

import numpy as np

from ..visual import VisualComponent
from ..shaders import Function
from ... import gloo



class TextureComponent(VisualComponent):
    """
    Component that reads a texture uniform.    
    """
    
    FRAG_CODE = """
        vec4 $texture_read() {
            vec2 tex_coord = $texture_coordinate();
            if(tex_coord.x < 0.0 || tex_coord.x > 1.0 || 
               tex_coord.y < 0.0 || tex_coord.y > 1.0) {
                discard;
            }
            return texture2D($texture, tex_coord.xy);            
        }
        """
    
    def __init__(self, texture, tex_coord_comp):
        self.frag_func = Function(self.FRAG_CODE)
        self.tex_coord_comp = tex_coord_comp
        self.texture = texture
        
    def _attach(self, visual):
        super(ShadingComponent, self)._attach(visual)
        visual._program.add_callback('frag_color', self.frag_func)
        
    def _detach(self, visual):
        self.visual._program.remove_callback('frag_color', self.frag_func)
        super(ShadingComponent, self)._detach()
        
    def activate(self, program, mode):
        # Texture coordinates are generated by a separate component.
        self.frag_func['texture_coordinate'] = self.tex_coord_comp.coord_shader()
        
        # TODO: add support for multiple lights
        self.frag_func['texture'] = ('uniform', 'sampler2D', self.texture)        

    @property
    def supported_draw_modes(self):
        return (self.DRAW_PRE_INDEXED, self.DRAW_UNINDEXED)


    
    
class VertexTextureCoordinateComponent(VisualComponent):
    """
    Class that reads texture coordinates from a vertex buffer.
    """
    VERT_CODE = """
        void $texture_coord_support() {
            $tex_local_pos = local_pos;
        }
    """
    
    FRAG_CODE = """
        vec2 $vertex_tex_coord() {
            vec4 tex_coord = map_local_to_tex($tex_local_pos));
            return $tex_coord.xy;
        }
        """
    
    def __init__(self, transform):
        self.frag_func = Function(self.FRAG_CODE)
        self.vert_func = Function(self.VERT_CODE)
        
    def _attach(self, visual):
        super(VertexNormalComponent, self)._attach(visual)
        visual._program.add_callback('vert_post_hook', self.vert_func)
        # don't attach the fragment function now; other components 
        # will call it.
        
    def _detach(self):
        self.visual._program.remove_callback('vert_post_hook', self.vert_func)
        super(VertexNormalComponent, self)._detach()
        
    def coord_shader(self):
        """
        Return the fragment shader function that returns a texture coordinate.
        """
        return self.frag_func
        
    def activate(self, program, mode):
        # explicitly declare a new variable (to be shared)
        # TODO: does this need to be explicit?
        self.frag_func['tex_local_pos'] = ('varying', 'vec4')   
        
        # automatically assign same variable to both
        self.vert_func['tex_local_pos'] = self.frag_func['tex_local_pos']

    @property
    def supported_draw_modes(self):
        return (self.DRAW_PRE_INDEXED, self.DRAW_UNINDEXED)


class TextureCoordinateComponent(VisualComponent):
    """
    Component that outputs texture coordinates derived from the local vertex 
    coordinate and a transform.    
    """
    
    VERT_CODE = """
        void $texture_coord_support() {
            $tex_coord_output = $tex_coord;
        }
    """
    
    FRAG_CODE = """
        vec2 $tex_coord() {
            return $tex_coord_input;
        }
        """
    
    def __init__(self, coords):
        self.frag_func = Function(self.FRAG_CODE)
        self.vert_func = Function(self.VERT_CODE)
        self.coords = coords
        
    def _attach(self, visual):
        super(VertexNormalComponent, self)._attach(visual)
        visual._program.add_callback('vert_post_hook', self.vert_func)
        # don't attach the fragment function now; other components 
        # will call it.
        
    def _detach(self):
        self.visual._program.remove_callback('vert_post_hook', self.vert_func)
        super(VertexNormalComponent, self)._detach()
        
    def coord_shader(self):
        """
        Return the fragment shader function that returns a texture coordinate.
        """
        return self.frag_func
        
    @property
    def vbo(self):
        if self._vbo is None:
            self._vbo = gloo.VertexBuffer(self.coords)
        return self._vbo
        
    def activate(self, program, mode):
        self.vert_func['tex_coord_output'] = ('varying', 'vec4')   
        self.frag_func['tex_coord_input'] = self.vert_func['tex_coord_output']
        self.vert_func['tex_coord'] = ('attribute', 'vec2', self.vbo)   

    @property
    def supported_draw_modes(self):
        return (self.DRAW_PRE_INDEXED, self.DRAW_UNINDEXED)
