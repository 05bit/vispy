# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

"""
Material components are modular shader components used for modifying fragment
colors to change the visual's appearance.

These generally create a function in the fragment shader that accepts a vec4
color as its only argument and returns a modified vec4 color.
"""

from __future__ import division

import numpy as np

from ..visual import VisualComponent
from ...shaders.composite import Function
from ... import gloo


class GridContourComponent(VisualComponent):
    """
    Draw grid lines across a surface.    
    """
    
    FRAG_CODE = """
        vec4 $grid_contour(vec4 color) {
            if ( mod($pos.x, $spacing.x) < 0.005 ||
                 mod($pos.y, $spacing.y) < 0.005 || 
                 mod($pos.z, $spacing.z) < 0.005 ) {
               return color + 0.7 * (vec4(1,1,1,1) - color);
            }
            else {
                return color;
            }
        }
        """
    
    VERT_CODE = """
        void $grid_contour_support() {
            $output_pos = local_position();
        }
        """
    
    def __init__(self, spacing):
        self.frag_func = Function(self.FRAG_CODE)
        self.vert_func = Function(self.VERT_CODE)
        self.spacing = spacing
        
    @property
    def color(self):
        return self._color
    
    @color.setter
    def color(self, c):
        self._color = c
        
    def _attach(self, visual):
        super(GridContourComponent, self)._attach(visual)
        visual._program.add_callback('frag_color', self.frag_func)
        visual._program.add_callback('vert_post_hook', self.vert_func)
        
    def _detach(self, visual):
        self.visual._program.remove_callback('frag_color', self.frag_func)
        self.visual._program.remove_callback('vert_post_hook', self.vert_func)
        super(GridContourComponent, self)._detach()
        
    def activate(self, program, mode):
        self.frag_func['pos'] = ('varying', 'vec4')
        self.frag_func['spacing'] = ('uniform', 'vec3', self.spacing)
        
        # automatically assign same variable to both
        self.vert_func['output_pos'] = self.frag_func['pos']

    @property
    def supported_draw_modes(self):
        return (self.DRAW_PRE_INDEXED, self.DRAW_UNINDEXED)


class ShadingComponent(VisualComponent):
    """
    Phong reflection and shading material.    
    """
    
    FRAG_CODE = """
        vec4 $shading(vec4 color) {
            vec3 norm = normalize($normal().xyz);
            vec3 light = normalize($light_direction.xyz);
            float p = dot(light, norm);
            p = (p < 0. ? 0. : p);
            vec4 diffuse = $light_color * p;
            diffuse.a = 1.0;
            p = dot(reflect(light, norm), vec3(0,0,1));
            if (p < 0.0) {
                p = 0.0;
            }
            vec4 specular = $light_color * 5.0 * pow(p, 100.);
            return color * ($ambient + diffuse) + specular;
        }
        """
    
    def __init__(self, normal_comp, lights, ambient=0.2):
        self.frag_func = Function(self.FRAG_CODE)
        self.normal_comp = normal_comp
        self.lights = lights
        self.ambient = ambient
        
    def _attach(self, visual):
        super(ShadingComponent, self)._attach(visual)
        visual._program.add_callback('frag_color', self.frag_func)
        
    def _detach(self, visual):
        self.visual._program.remove_callback('frag_color', self.frag_func)
        super(ShadingComponent, self)._detach()
        
    def activate(self, program, mode):
        # Normals are generated by output of another component
        self.frag_func['normal'] = self.normal_comp.normal_shader()
        
        # TODO: add support for multiple lights
        self.frag_func['light_direction'] = ('uniform', 'vec4', tuple(self.lights[0][0][:3]) + (1,))
        self.frag_func['light_color'] = ('uniform', 'vec4', tuple(self.lights[0][1][:3]) + (1,))
        self.frag_func['ambient'] = ('uniform', 'float', self.ambient)
        

    @property
    def supported_draw_modes(self):
        return (self.DRAW_PRE_INDEXED, self.DRAW_UNINDEXED)


